set traceDisplay = long.

(* Define key type and channel *)
type key.
free scA: channel.

(* Encryption, Decryption, and HMAC functions *)
fun enc(bitstring, key): bitstring.
fun dec(bitstring, key): bitstring.
fun hmac(bitstring, nat, key): bitstring.

(* Equations for symmetric encryption and decryption *)
equation forall m: bitstring, k: key; dec(enc(m, k), k) = m.
equation forall m: bitstring, k: key; enc(dec(m, k), k) = m.

(* Table to store freshness values to prevent replay attacks *)
table freshness(bitstring, nat).
table keys(bitstring, nat, key).

(* Events to track message sending, receiving, and replay detection *)
event message_received_B(bitstring, nat).
event message_send_A(bitstring, nat).
event replay_attack(bitstring, nat).
event replay_msg(bitstring, nat).

(* Key server *)
let Trant(sci:bitstring, an:nat) =
    new sak:key;
    insert keys(sci, an, sak).

(* Peer A sends a message to Peer B *)
let Alice(m: bitstring, sci_A: bitstring, k_A: key, fresh: nat) =
    let msg = enc(m, k_A) in
    let icv = hmac(msg, fresh, k_A) in
    event message_send_A(m, fresh);
    out(scA, (sci_A, fresh, msg, icv)).

(* Peer B receives and verifies the message from Peer A *)
let Bob(sci_A: bitstring, k_A: key) =
    in(scA, (sci: bitstring, fresh: nat, x: bitstring, icv: bitstring));
    get freshness(sci, fv) suchthat fv >= fresh in 0 else
        if sci = sci_A && icv = hmac(x, fresh, k_A) then
            let received_msg = dec(x, k_A) in
            insert freshness(sci_A, fresh);
            event message_received_B(received_msg, fresh)
        else
            event replay_attack(sci, fresh).

(* Peer C attempts a replay attack *)
let Charlie_replay() =
    in(scA, (sci: bitstring, fresh: nat, x: bitstring, icv: bitstring));
    event replay_msg(sci, fresh);  
    out(scA, (sci, fresh+10, x, icv)).

(* Confidentiality Query: Ensure the attacker cannot learn the message *)
query m: bitstring, fresh: nat;
    event(message_received_B(m, fresh)) && attacker(m) ==> false.

(* Authentication Query: Ensure every message received was actually sent *)
query m: bitstring, fresh: nat;
    event(message_received_B(m, fresh)) ==> event(message_send_A(m, fresh)).

(* Replay Attack Query: Ensure no message is accepted after a replay attack *)
query sci: bitstring, fresh: nat;
    event(replay_attack(sci, fresh)) ==> event(replay_msg(sci, fresh)).

(* Main Process *)
process
    new k_A: key;
    new sci_A: bitstring;
    new msg: bitstring;
    (* Key distribution phase *)
    (!Trant(sci_A, 0)) |
    
    phase 1;

    insert freshness(sci_A, 1); 
    (!Alice(msg, sci_A, k_A, 2) | !Bob(sci_A, k_A) | !Charlie_replay())
