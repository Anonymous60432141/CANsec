set traceDisplay = long.

(* Define key type and secure communication channel *)
type key.
free scA: channel.  (* scA is the secure communication channel between Alice and Bob *)

(* Encryption, Decryption, and HMAC functions *)
fun enc(bitstring, key): bitstring.   (* Symmetric encryption function *)
fun dec(bitstring, key): bitstring.   (* Symmetric decryption function *)
fun key_enc(key, key): bitstring.     (* Encryption of a key using another key *)
fun key_dec(bitstring, key): key.     (* Decryption of a key using another key *)
fun hmac(bitstring, nat, nat, key): bitstring.  (* HMAC function with additional parameters for security association *)
fun kdf(key, nat): key.   (* Key Derivation Function (KDF) *)

(* Symmetric encryption and decryption equations *)
equation forall m: bitstring, k: key; dec(enc(m, k), k) = m.  (* Decoding an encoded message with the same key returns the original message *)
equation forall m: bitstring, k: key; enc(dec(m, k), k) = m.  (* Encoding a decoded message with the same key returns the original message *)
equation forall k1: key, k2: key; key_dec(key_enc(k1, k2), k2) = k1.  (* Decryption of an encrypted key using the same key returns the original key *)

(* Every peer will have there own association key table with the same entries, so it is declared as a global variable to avoid redundancy. *)
(* Tables holding freshness and key counter values for all peers *)
table freshness(bitstring, nat, nat).  (* Table for tracking freshness to prevent replay attacks *)
table association_keys(bitstring, nat, key).  (* Table for storing association keys *)

(* Events marking message exchange between Alice and Bob *)
event message_received_Bob(bitstring, nat).     (* Event for when Bob successfully receives a message *)
event message_send_Alice(bitstring, nat).       (* Event for when Alice sends a message *)

(* Trusted key server process: Trant *)
(* Generates and sends an association key (SAK) to Alice and Bob *)
let Trant(sci_A:bitstring, an:nat, fresh:nat, szk:key) = 
    (* The context are set by the user here we have taken numbers as contexts for key generation *)
    (* These contexts are comman for all the peers *)
    (* We have taken numbers for simplicity can also use bitstring *)
    let kek = kdf(szk, 10) in  (* Generate Key Encryption Key (KEK) *)
    let ick = kdf(szk, 20) in  (* Generate Integrity Check Key (ICK) *)
    new sak:key;  (* Generate new Secure Association Key (SAK) *)
    let msg = key_enc(sak, kek) in  (* Encrypt SAK using KEK *)
    let icv = hmac(msg, an, 1, ick) in  (* Generate HMAC for integrity check *)
    out(scA, (sci_A, an, fresh, msg, icv)).  (* Send encrypted SAK with integrity check *)

(* Process representing Alice sending a message to Bob *)
let Alice(m: bitstring, sci_A: bitstring, szk: key, an: nat) =
    get association_keys(=sci_A, =an, sak_alice) in(  (* Retrieve association key from table *)
        let packet_number = 2 in  (* Set packet number for message *)
        let msg = enc(m, sak_alice) in  (* Encrypt message with association key *)
        let icv2 = hmac(msg, an, packet_number, sak_alice) in  (* Generate HMAC for integrity check *)
        event message_send_Alice(m, packet_number);  (* Trigger event to mark message sent by Alice *)
        out(scA, (sci_A, an, packet_number, msg, icv2)))  (* Send encrypted message with HMAC *)
    else 0.  (* If association key is not available, terminate *)

(* Process representing Bob receiving and verifying a message from Alice *)
let Bob(sci_A: bitstring, szk: key) =
    in(scA, (sci: bitstring, an: nat, packet_number: nat, x: bitstring, icv: bitstring));
    get association_keys(=sci, =an, ska_A) in
        (get freshness(=sci, =an, fv) suchthat fv >= packet_number in 0 else(  (* Check freshness to prevent replay attacks *)
            if sci = sci_A && icv = hmac(x, an, packet_number, ska_A) then  (* Validate message with HMAC *)
                (let received_msg = dec(x, ska_A) in  (* Decrypt received message *)
                insert freshness(sci_A, an, packet_number);  (* Update freshness table *)
                event message_received_Bob(received_msg, packet_number))  (* Trigger event to mark message received by Bob *)
            else 0)
        )
        else
            ( let ick = kdf(szk, 20) in  (* Generate ICK if key not found in association_keys table *)
            if sci = sci_A && icv = hmac(x, an, packet_number, ick) then
            (
                let kek = kdf(szk, 10) in  (* Generate KEK *)
                let sak = key_dec(x, kek) in  (* Decrypt and retrieve SAK *)
                insert freshness(sci_A, an, packet_number);  (* Insert freshness for received packet *)
                insert association_keys(sci_A, an, sak)  (* Insert association key in table *)
            )
            else 0).

(* Confidentiality query: Ensure messages cannot be intercepted *)
query m: bitstring, packet_number: nat;
    event(message_received_Bob(m, packet_number)) && attacker(m) ==> false.

(* Authentication query to prevent replay attacks *)
query m: bitstring, packet_number: nat;
    inj-event(message_received_Bob(m, packet_number)) ==> inj-event(message_send_Alice(m, packet_number)).

(* Main process to simulate message exchange between Alice and Bob *)
process
    new szk: key;  (* Session key for Alice and Bob *)
    new sci_A: bitstring;  (* Identifier for Alice's secure channel *)
    new msg: bitstring;  (* Message content *)
    let an = 1 in  (* Initial association number *)
    insert freshness(sci_A, 0, 0);  (* Initialize freshness table *)
    (!Trant(sci_A, an, 1, szk) | !Bob(sci_A, szk))|  (* Run Trant and Bob processes in parallel *)
    
    phase 1;  (* Transition to next phase *)
    (!Alice(msg, sci_A, szk, 1) | !Bob(sci_A, szk))  (* Run Alice and Bob communication processes in parallel *)
