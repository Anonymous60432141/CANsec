(*public channel*)
type key.
type sci.(* type for the secure channel identifier *)

free c:channel. 
free k:key [private].

const szk:key [private].

(* Channel identifier for the supplicants *)

free sciA:sci.
free sciB:sci.

(* free Cocks:bitstring [private].names that are not known by the attacker must be declayered private *)
(* free RSA:bitstring [private]. *)
(* query attacker(Cocks). *)

(* fun(t1,tn ...):type //one way functions are declayered like this we can use [private] to make the function private *)
fun enc(bitstring, szk):bitstring.
fun h(bitstring, szk):bitstring.
fun derive_SAK(key, version): key.
(* -------private contructors are useful for modeling tables for keys------- *)

(* relationship between the constructors are defined by the destructors *)
fun dec(bitstring, szk):bitstring 
reduc forall m:bitstring, k:key; dec(enc(m, k), k) = m.

(* destructor for matching the ICV *)
reduc forall m:bitstring, k:key; get_message(h(m, k)) = m.

(* reduc forall m:bitstring, k:key; h(m, k)  *)
(* when no rules are applied then destructor fails, a destructor must be determinstic *)

(* table construction *)

(* proverif has table ds for persistant storage process can populate and access data but cannot delete *)
(* tables are not accessable by the attackers *)

(* create table for supplicants *)

(* keyserver that creates new key for all the participants *)

