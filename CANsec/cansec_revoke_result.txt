Linear part: No equation.
Convergent part:
dec(enc(m,k),k) = m
enc(dec(m,k),k) = m
Completing equations...
Completed equations:
enc(dec(m,k),k) = m
dec(enc(m,k),k) = m
Process 0 (that is, the initial process):
{1}new k_A: key;
{2}new sci_A: bitstring;
{3}new msg: bitstring;
{4}out(scA, k_A);
{5}insert association_keys(sci_A,0,k_A);
{6}insert freshness(sci_A,0);
(
    {7}!
    {8}let m: bitstring = msg in
    {9}let sci_A_1: bitstring = sci_A in
    {10}let fresh: nat = 1 in
    {11}let an: nat = 0 in
    {16}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {12}let msg_1: bitstring = enc(m,k_A_1) in
    {13}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {14}event message_send_A(m,fresh);
    {15}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {17}!
    {18}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {24}get association_keys(=sci,=an_1,sak: key) in
    {19}if (icv_1 = hmac(sci,x,fresh_1,an_1,sak)) then
    {23}get freshness(=sci,fv: nat) suchthat (fv ≥ fresh_1) in
        0
    else
        {20}insert freshness(sci,fresh_1);
        {21}let received_msg: bitstring = dec(x,sak) in
        {22}event message_received_B(received_msg,fresh_1)
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new k_A: key;
{2}new sci_A: bitstring;
{3}new msg: bitstring;
{4}out(scA, k_A);
{5}insert association_keys(sci_A,0,k_A);
{6}insert freshness(sci_A,0);
(
    {7}!
    {11}let an: nat = 0 in
    {9}let sci_A_1: bitstring = sci_A in
    {16}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {10}let fresh: nat = 1 in
    {8}let m: bitstring = msg in
    {14}event message_send_A(m,fresh);
    {12}let msg_1: bitstring = enc(m,k_A_1) in
    {13}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {15}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {17}!
    {18}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {24}get association_keys(=sci,=an_1,sak: key) in
    {19}if (icv_1 = hmac(sci,x,fresh_1,an_1,sak)) then
    {23}get freshness(=sci,fv: nat) suchthat (fv ≥ fresh_1) in
        0
    else
        {20}insert freshness(sci,fresh_1);
        {21}let received_msg: bitstring = dec(x,sak) in
        {22}event message_received_B(received_msg,fresh_1)
)

-- Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1))
goal reachable: attacker(fresh_2) && attacker(m_1) -> event(message_received_B(m_1,fresh_2)) && attacker(m_1)

Derivation:

1. We assume as hypothesis that
attacker(m_1).

2. The message k_A[] may be sent to the attacker at output {4}.
attacker(k_A[]).

3. Using the function 0 the attacker may obtain 0.
attacker(0).

4. We assume as hypothesis that
attacker(fresh_2).

5. By 1, the attacker may know m_1.
By 2, the attacker may know k_A[].
Using the function enc the attacker may obtain enc(m_1,k_A[]).
attacker(enc(m_1,k_A[])).

6. The entry association_keys(sci_A[],0,k_A[]) may be inserted in a table at insert {5}.
table(association_keys(sci_A[],0,k_A[])).

7. The entry association_keys(sci_A[],0,k_A[]) that may be in a table by 6 may be read at get {16}.
So the message (sci_A[],0,1,enc(msg[],k_A[]),hmac(sci_A[],enc(msg[],k_A[]),1,0,k_A[])) may be sent to the attacker at output {15}.
attacker((sci_A[],0,1,enc(msg[],k_A[]),hmac(sci_A[],enc(msg[],k_A[]),1,0,k_A[]))).

8. By 7, the attacker may know (sci_A[],0,1,enc(msg[],k_A[]),hmac(sci_A[],enc(msg[],k_A[]),1,0,k_A[])).
Using the function 1-proj-5-tuple the attacker may obtain sci_A[].
attacker(sci_A[]).

9. By 8, the attacker may know sci_A[].
By 5, the attacker may know enc(m_1,k_A[]).
By 4, the attacker may know fresh_2.
By 3, the attacker may know 0.
By 2, the attacker may know k_A[].
Using the function hmac the attacker may obtain hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[]).
attacker(hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[])).

10. By 8, the attacker may know sci_A[].
By 3, the attacker may know 0.
By 4, the attacker may know fresh_2.
By 5, the attacker may know enc(m_1,k_A[]).
By 9, the attacker may know hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[]).
Using the function 5-tuple the attacker may obtain (sci_A[],0,fresh_2,enc(m_1,k_A[]),hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[])).
attacker((sci_A[],0,fresh_2,enc(m_1,k_A[]),hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[]))).

11. The message (sci_A[],0,fresh_2,enc(m_1,k_A[]),hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[])) that the attacker may have by 10 may be received at input {18}.
The entry association_keys(sci_A[],0,k_A[]) that may be in a table by 6 may be read at get {24}.
So event message_received_B(m_1,fresh_2) may be executed at {22}.
event(message_received_B(m_1,fresh_2)).

12. By 11, event(message_received_B(m_1,fresh_2)).
By 1, attacker(m_1).
The goals are reached, combined in the following fact:
event(message_received_B(m_1,fresh_2)) && attacker(m_1).


A more detailed output of the traces is available with
  set traceDisplay = long.

new k_A: key creating k_A_2 at {1}

new sci_A: bitstring creating sci_A_2 at {2}

new msg: bitstring creating msg_2 at {3}

out(scA, ~M) with ~M = k_A_2 at {4}

insert association_keys(sci_A_2,0,k_A_2) at {5}

insert freshness(sci_A_2,0) at {6}

get association_keys(sci_A_2,0,k_A_2) at {16} in copy a

event message_send_A(msg_2,1) at {14} in copy a

out(scA, (~M_1,0,1,~M_2,~M_3)) with ~M_1 = sci_A_2, ~M_2 = enc(msg_2,k_A_2), ~M_3 = hmac(sci_A_2,enc(msg_2,k_A_2),1,0,k_A_2) at {15} in copy a

in(scA, (~M_1,0,a_1,enc(a_2,~M),hmac(~M_1,enc(a_2,~M),a_1,0,~M))) with ~M_1 = sci_A_2, enc(a_2,~M) = enc(a_2,k_A_2), hmac(~M_1,enc(a_2,~M),a_1,0,~M) = hmac(sci_A_2,enc(a_2,k_A_2),a_1,0,k_A_2) at {18} in copy a_3

get association_keys(sci_A_2,0,k_A_2) at {24} in copy a_3

get freshness(=sci_A_2,fv: nat) suchthat (fv ≥ a_1): else branch taken at {23} in copy a_3

insert freshness(sci_A_2,a_1) at {20} in copy a_3

event message_received_B(dec(enc(a_2,k_A_2),k_A_2),a_1) at {22} in copy a_3 (goal)

The event message_received_B(a_2,a_1) is executed at {22} in copy a_3.
The attacker has the message a_2.
A trace has been found.
RESULT not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is false.
-- Query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2))
goal reachable: b-event(message_send_A(msg[],1)) && attacker(m_1) && attacker(fresh_2) -> event(message_received_B(m_1,fresh_2))

Derivation:

1. The message k_A[] may be sent to the attacker at output {4}.
attacker(k_A[]).

2. Using the function 0 the attacker may obtain 0.
attacker(0).

3. We assume as hypothesis that
attacker(fresh_2).

4. We assume as hypothesis that
attacker(m_1).

5. By 4, the attacker may know m_1.
By 1, the attacker may know k_A[].
Using the function enc the attacker may obtain enc(m_1,k_A[]).
attacker(enc(m_1,k_A[])).

6. The entry association_keys(sci_A[],0,k_A[]) may be inserted in a table at insert {5}.
table(association_keys(sci_A[],0,k_A[])).

7. The entry association_keys(sci_A[],0,k_A[]) that may be in a table by 6 may be read at get {16}.
The event message_send_A(msg[],1) may be executed at {14}.
So the message (sci_A[],0,1,enc(msg[],k_A[]),hmac(sci_A[],enc(msg[],k_A[]),1,0,k_A[])) may be sent to the attacker at output {15}.
attacker((sci_A[],0,1,enc(msg[],k_A[]),hmac(sci_A[],enc(msg[],k_A[]),1,0,k_A[]))).

8. By 7, the attacker may know (sci_A[],0,1,enc(msg[],k_A[]),hmac(sci_A[],enc(msg[],k_A[]),1,0,k_A[])).
Using the function 1-proj-5-tuple the attacker may obtain sci_A[].
attacker(sci_A[]).

9. By 8, the attacker may know sci_A[].
By 5, the attacker may know enc(m_1,k_A[]).
By 3, the attacker may know fresh_2.
By 2, the attacker may know 0.
By 1, the attacker may know k_A[].
Using the function hmac the attacker may obtain hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[]).
attacker(hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[])).

10. By 8, the attacker may know sci_A[].
By 2, the attacker may know 0.
By 3, the attacker may know fresh_2.
By 5, the attacker may know enc(m_1,k_A[]).
By 9, the attacker may know hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[]).
Using the function 5-tuple the attacker may obtain (sci_A[],0,fresh_2,enc(m_1,k_A[]),hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[])).
attacker((sci_A[],0,fresh_2,enc(m_1,k_A[]),hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[]))).

11. The message (sci_A[],0,fresh_2,enc(m_1,k_A[]),hmac(sci_A[],enc(m_1,k_A[]),fresh_2,0,k_A[])) that the attacker may have by 10 may be received at input {18}.
The entry association_keys(sci_A[],0,k_A[]) that may be in a table by 6 may be read at get {24}.
So event message_received_B(m_1,fresh_2) may be executed at {22}.
event(message_received_B(m_1,fresh_2)).

12. By 11, event(message_received_B(m_1,fresh_2)).
The goal is reached, represented in the following fact:
event(message_received_B(m_1,fresh_2)).


A more detailed output of the traces is available with
  set traceDisplay = long.

new k_A: key creating k_A_2 at {1}

new sci_A: bitstring creating sci_A_2 at {2}

new msg: bitstring creating msg_2 at {3}

out(scA, ~M) with ~M = k_A_2 at {4}

insert association_keys(sci_A_2,0,k_A_2) at {5}

insert freshness(sci_A_2,0) at {6}

get association_keys(sci_A_2,0,k_A_2) at {16} in copy a

event message_send_A(msg_2,1) at {14} in copy a

out(scA, (~M_1,0,1,~M_2,~M_3)) with ~M_1 = sci_A_2, ~M_2 = enc(msg_2,k_A_2), ~M_3 = hmac(sci_A_2,enc(msg_2,k_A_2),1,0,k_A_2) at {15} in copy a

in(scA, (~M_1,0,a_1,enc(a_2,~M),hmac(~M_1,enc(a_2,~M),a_1,0,~M))) with ~M_1 = sci_A_2, enc(a_2,~M) = enc(a_2,k_A_2), hmac(~M_1,enc(a_2,~M),a_1,0,~M) = hmac(sci_A_2,enc(a_2,k_A_2),a_1,0,k_A_2) at {18} in copy a_3

get association_keys(sci_A_2,0,k_A_2) at {24} in copy a_3

get freshness(=sci_A_2,fv: nat) suchthat (fv ≥ a_1): else branch taken at {23} in copy a_3

insert freshness(sci_A_2,a_1) at {20} in copy a_3

event message_received_B(dec(enc(a_2,k_A_2),k_A_2),a_1) at {22} in copy a_3 (goal)

The event message_received_B(a_2,a_1) is executed at {22} in copy a_3.
A trace has been found.
RESULT event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) is false.

--------------------------------------------------------------
Verification summary:

Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is false.

Query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) is false.

--------------------------------------------------------------

Linear part: No equation.
Convergent part:
dec(enc(m,k),k) = m
enc(dec(m,k),k) = m
Completing equations...
Completed equations:
enc(dec(m,k),k) = m
dec(enc(m,k),k) = m
Process 0 (that is, the initial process):
{1}new k_A: key;
{2}new sci_A: bitstring;
{3}new msg: bitstring;
{4}insert association_keys(sci_A,0,k_A);
{5}insert freshness(sci_A,0);
(
    {6}!
    {7}let m: bitstring = msg in
    {8}let sci_A_1: bitstring = sci_A in
    {9}let fresh: nat = 1 in
    {10}let an: nat = 0 in
    {15}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {11}let msg_1: bitstring = enc(m,k_A_1) in
    {12}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {13}event message_send_A(m,fresh);
    {14}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {16}!
    {17}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {23}get association_keys(=sci,=an_1,sak: key) in
    {18}if (icv_1 = hmac(sci,x,fresh_1,an_1,sak)) then
    {22}get freshness(=sci,fv: nat) suchthat (fv ≥ fresh_1) in
        0
    else
        {19}insert freshness(sci,fresh_1);
        {20}let received_msg: bitstring = dec(x,sak) in
        {21}event message_received_B(received_msg,fresh_1)
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new k_A: key;
{2}new sci_A: bitstring;
{3}new msg: bitstring;
{4}insert association_keys(sci_A,0,k_A);
{5}insert freshness(sci_A,0);
(
    {6}!
    {10}let an: nat = 0 in
    {8}let sci_A_1: bitstring = sci_A in
    {15}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {9}let fresh: nat = 1 in
    {7}let m: bitstring = msg in
    {13}event message_send_A(m,fresh);
    {11}let msg_1: bitstring = enc(m,k_A_1) in
    {12}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {14}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {16}!
    {17}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {23}get association_keys(=sci,=an_1,sak: key) in
    {18}if (icv_1 = hmac(sci,x,fresh_1,an_1,sak)) then
    {22}get freshness(=sci,fv: nat) suchthat (fv ≥ fresh_1) in
        0
    else
        {19}insert freshness(sci,fresh_1);
        {20}let received_msg: bitstring = dec(x,sak) in
        {21}event message_received_B(received_msg,fresh_1)
)

-- Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1))
RESULT not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is true.
-- Query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2))
goal reachable: b-event(message_send_A(msg[],1)) -> event(message_received_B(dec(enc(msg[],k_A[]),k_A[]),1))
RESULT event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) is true.

--------------------------------------------------------------
Verification summary:

Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is true.

Query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) is true.

--------------------------------------------------------------

