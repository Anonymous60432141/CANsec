Linear part: No equation.
Convergent part:
dec(enc(m,k),k) = m
enc(dec(m,k),k) = m
Completing equations...
Completed equations:
enc(dec(m,k),k) = m
dec(enc(m,k),k) = m
Process 0 (that is, the initial process):
{1}new k_A: key;
{2}!
{3}new sci_A: bitstring;
{4}new msg: bitstring;
{5}insert association_keys(sci_A,0,k_A);
{6}out(counter, 1);
(
    {7}!
    {8}let m: bitstring = msg in
    {9}let sci_A_1: bitstring = sci_A in
    {10}let fresh: nat = 1 in
    {11}let an: nat = 0 in
    {16}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {12}let msg_1: bitstring = enc(m,k_A_1) in
    {13}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {14}event message_send_A(m,fresh);
    {15}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {17}!
    {18}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {24}get association_keys(=sci,=an_1,sak: key) in
    {19}in(counter, f: nat);
    {20}if ((icv_1 = hmac(sci,x,fresh_1,an_1,sak)) && (f < fresh_1)) then
    {21}out(counter, fresh_1);
    {22}let received_msg: bitstring = dec(x,sak) in
    {23}event message_received_B(received_msg,fresh_1)
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new k_A: key;
{2}!
{3}new sci_A: bitstring;
{4}new msg: bitstring;
{5}insert association_keys(sci_A,0,k_A);
{6}out(counter, 1);
(
    {7}!
    {11}let an: nat = 0 in
    {9}let sci_A_1: bitstring = sci_A in
    {16}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {10}let fresh: nat = 1 in
    {8}let m: bitstring = msg in
    {14}event message_send_A(m,fresh);
    {12}let msg_1: bitstring = enc(m,k_A_1) in
    {13}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {15}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {17}!
    {18}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {24}get association_keys(=sci,=an_1,sak: key) in
    {19}in(counter, f: nat);
    {20}if ((icv_1 = hmac(sci,x,fresh_1,an_1,sak)) && (f < fresh_1)) then
    {21}out(counter, fresh_1);
    {22}let received_msg: bitstring = dec(x,sak) in
    {23}event message_received_B(received_msg,fresh_1)
)

-- Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1))
RESULT not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is true.
-- Query inj-event(message_received_B(m_1,fresh_2)) ==> inj-event(message_send_A(m_1,fresh_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query inj-event(message_received_B(m_1,fresh_2)) ==> inj-event(message_send_A(m_1,fresh_2))
RESULT inj-event(message_received_B(m_1,fresh_2)) ==> inj-event(message_send_A(m_1,fresh_2)) is true.

--------------------------------------------------------------
Verification summary:

Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is true.

Query inj-event(message_received_B(m_1,fresh_2)) ==> inj-event(message_send_A(m_1,fresh_2)) is true.

--------------------------------------------------------------

