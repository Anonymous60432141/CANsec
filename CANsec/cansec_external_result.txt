Linear part: No equation.
Convergent part:
dec(enc(m,k),k) = m
enc(dec(m,k),k) = m
Completing equations...
Completed equations:
enc(dec(m,k),k) = m
dec(enc(m,k),k) = m
Process 0 (that is, the initial process):
{1}new k_A: key;
{2}new sci_A: bitstring;
{3}new msg: bitstring;
{4}insert association_keys(sci_A,0,k_A);
{5}insert freshness(sci_A,0);
(
    {6}!
    {7}let m: bitstring = msg in
    {8}let sci_A_1: bitstring = sci_A in
    {9}let fresh: nat = 1 in
    {10}let an: nat = 0 in
    {15}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {11}let msg_1: bitstring = enc(m,k_A_1) in
    {12}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {13}event message_send_A(m,fresh);
    {14}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {16}!
    {17}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {23}get association_keys(=sci,=an_1,sak: key) in
    {18}if (icv_1 = hmac(sci,x,fresh_1,an_1,sak)) then
    {22}get freshness(=sci,fv: nat) suchthat (fv â‰¥ fresh_1) in
        0
    else
        {19}insert freshness(sci,fresh_1);
        {20}let received_msg: bitstring = dec(x,sak) in
        {21}event message_received_B(received_msg,fresh_1)
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new k_A: key;
{2}new sci_A: bitstring;
{3}new msg: bitstring;
{4}insert association_keys(sci_A,0,k_A);
{5}insert freshness(sci_A,0);
(
    {6}!
    {10}let an: nat = 0 in
    {8}let sci_A_1: bitstring = sci_A in
    {15}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {9}let fresh: nat = 1 in
    {7}let m: bitstring = msg in
    {13}event message_send_A(m,fresh);
    {11}let msg_1: bitstring = enc(m,k_A_1) in
    {12}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {14}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {16}!
    {17}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {23}get association_keys(=sci,=an_1,sak: key) in
    {18}if (icv_1 = hmac(sci,x,fresh_1,an_1,sak)) then
    {22}get freshness(=sci,fv: nat) suchthat (fv â‰¥ fresh_1) in
        0
    else
        {19}insert freshness(sci,fresh_1);
        {20}let received_msg: bitstring = dec(x,sak) in
        {21}event message_received_B(received_msg,fresh_1)
)

-- Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1))
RESULT not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is true.
-- Query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2))
goal reachable: b-event(message_send_A(msg[],1)) -> event(message_received_B(dec(enc(msg[],k_A[]),k_A[]),1))
RESULT event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) is true.

--------------------------------------------------------------
Verification summary:

Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is true.

Query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) is true.

--------------------------------------------------------------

