Linear part: No equation.
Convergent part:
dec(enc(m,k),k) = m
enc(dec(m,k),k) = m
Completing equations...
Completed equations:
enc(dec(m,k),k) = m
dec(enc(m,k),k) = m
Process 0 (that is, the initial process):
{1}new k_A: key;
{2}!
{3}new sci_A: bitstring;
{4}new msg: bitstring;
{5}insert association_keys(sci_A,0,k_A);
{6}insert freshness(sci_A,0);
(
    {7}let m: bitstring = msg in
    {8}let sci_A_1: bitstring = sci_A in
    {9}let fresh: nat = 1 in
    {10}let an: nat = 0 in
    {15}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {11}let msg_1: bitstring = enc(m,k_A_1) in
    {12}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {13}event message_send_A(m,fresh);
    {14}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {16}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {22}get association_keys(=sci,=an_1,sak: key) in
    {17}if (icv_1 = hmac(sci,x,fresh_1,an_1,sak)) then
    {21}get freshness(=sci,fv: nat) suchthat (fv â‰¥ fresh_1) in
        0
    else
        {18}insert freshness(sci,fresh_1);
        {19}let received_msg: bitstring = dec(x,sak) in
        {20}event message_received_B(received_msg,fresh_1)
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new k_A: key;
{2}!
{3}new sci_A: bitstring;
{4}new msg: bitstring;
{5}insert association_keys(sci_A,0,k_A);
{6}insert freshness(sci_A,0);
(
    {10}let an: nat = 0 in
    {8}let sci_A_1: bitstring = sci_A in
    {15}get association_keys(=sci_A_1,=an,k_A_1: key) in
    {9}let fresh: nat = 1 in
    {7}let m: bitstring = msg in
    {13}event message_send_A(m,fresh);
    {11}let msg_1: bitstring = enc(m,k_A_1) in
    {12}let icv: bitstring = hmac(sci_A_1,msg_1,fresh,an,k_A_1) in
    {14}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {16}in(scA, (sci: bitstring,an_1: nat,fresh_1: nat,x: bitstring,icv_1: bitstring));
    {22}get association_keys(=sci,=an_1,sak: key) in
    {17}if (icv_1 = hmac(sci,x,fresh_1,an_1,sak)) then
    {21}get freshness(=sci,fv: nat) suchthat (fv â‰¥ fresh_1) in
        0
    else
        {18}insert freshness(sci,fresh_1);
        {19}let received_msg: bitstring = dec(x,sak) in
        {20}event message_received_B(received_msg,fresh_1)
)

-- Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1))
RESULT not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is true.
-- Query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2))
goal reachable: b-event(message_send_A(msg_2,1)) -> event(message_received_B(dec(enc(msg_2,k_A[]),k_A[]),1))
Abbreviations:
msg_2 = msg[!1 = @sid]
RESULT event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) is true.

--------------------------------------------------------------
Verification summary:

Query not (event(message_received_B(m_1,fresh_2)) && attacker(m_1)) is true.

Query event(message_received_B(m_1,fresh_2)) ==> event(message_send_A(m_1,fresh_2)) is true.

--------------------------------------------------------------

