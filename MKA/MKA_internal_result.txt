Linear part: No equation.
Convergent part:
dec(enc(m,k),k) = m
enc(dec(m,k),k) = m
key_dec(key_enc(k1,k2),k2) = k1
Completing equations...
Completed equations:
key_dec(key_enc(k1,k2),k2) = k1
enc(dec(m,k),k) = m
dec(enc(m,k),k) = m
Process 0 (that is, the initial process):
{1}new szk: key;
{2}out(scA, szk);
{3}new sci_A: bitstring;
{4}new msg: bitstring;
{5}let an: nat = 1 in
{6}insert freshness(sci_A,0,0);
(
    {7}!
    {8}let sci_A_1: bitstring = sci_A in
    {9}let fresh: nat = 1 in
    {10}let szk_1: key = szk in
    {11}let ick_context: nat = 20 in
    {12}let kek_context: nat = 10 in
    {13}let kek: key = kdf(szk_1,kek_context) in
    {14}let ick: key = kdf(szk_1,ick_context) in
    {15}new sak: key;
    {16}let msg_1: bitstring = key_enc(sak,kek) in
    {17}let icv: bitstring = hmac(msg_1,an,1,ick) in
    {18}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {19}!
    {20}let sci_A_2: bitstring = sci_A in
    {21}let szk_2: key = szk in
    {22}in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    {36}get association_keys(=sci,=an_1,ska_A: key) in
    (
        {27}get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            {23}if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            {24}let received_msg: bitstring = dec(x,ska_A) in
            {25}insert freshness(sci_A_2,an_1,packet_number);
            {26}event message_received_Bob(received_msg,packet_number)
    )
    else
        {28}let ick_context_1: nat = 20 in
        {29}let kek_context_1: nat = 10 in
        {30}let ick_1: key = kdf(szk_2,ick_context_1) in
        {31}if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        {32}let kek_1: key = kdf(szk_2,kek_context_1) in
        {33}let sak_1: key = key_dec(x,kek_1) in
        {34}insert freshness(sci_A_2,an_1,packet_number);
        {35}insert association_keys(sci_A_2,an_1,sak_1)
) | (
    {37}phase 1;
    (
        {38}!
        {39}let m: bitstring = msg in
        {40}let sci_A_3: bitstring = sci_A in
        {41}let szk_3: key = szk in
        {42}let an_2: nat = 1 in
        {48}get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        {43}let packet_number_1: nat = 2 in
        {44}let msg_2: bitstring = enc(m,sak_alice) in
        {45}let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        {46}event message_send_Alice(m,packet_number_1);
        {47}out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        {49}!
        {50}let sci_A_4: bitstring = sci_A in
        {51}let szk_4: key = szk in
        {52}in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        {66}get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            {57}get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                {53}if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                {54}let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                {55}insert freshness(sci_A_4,an_3,packet_number_2);
                {56}event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            {58}let ick_context_2: nat = 20 in
            {59}let kek_context_2: nat = 10 in
            {60}let ick_2: key = kdf(szk_4,ick_context_2) in
            {61}if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            {62}let kek_2: key = kdf(szk_4,kek_context_2) in
            {63}let sak_2: key = key_dec(x_1,kek_2) in
            {64}insert freshness(sci_A_4,an_3,packet_number_2);
            {65}insert association_keys(sci_A_4,an_3,sak_2)
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new szk: key;
{2}out(scA, szk);
{3}new sci_A: bitstring;
{4}new msg: bitstring;
{6}insert freshness(sci_A,0,0);
(
    {7}!
    {15}new sak: key;
    {12}let kek_context: nat = 10 in
    {10}let szk_1: key = szk in
    {13}let kek: key = kdf(szk_1,kek_context) in
    {16}let msg_1: bitstring = key_enc(sak,kek) in
    {11}let ick_context: nat = 20 in
    {14}let ick: key = kdf(szk_1,ick_context) in
    {5}let an: nat = 1 in
    {17}let icv: bitstring = hmac(msg_1,an,1,ick) in
    {9}let fresh: nat = 1 in
    {8}let sci_A_1: bitstring = sci_A in
    {18}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {19}!
    {22}in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    {20}let sci_A_2: bitstring = sci_A in
    {36}get association_keys(=sci,=an_1,ska_A: key) in
    (
        {27}get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            {23}if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            {25}insert freshness(sci_A_2,an_1,packet_number);
            {24}let received_msg: bitstring = dec(x,ska_A) in
            {26}event message_received_Bob(received_msg,packet_number)
    )
    else
        {28}let ick_context_1: nat = 20 in
        {21}let szk_2: key = szk in
        {30}let ick_1: key = kdf(szk_2,ick_context_1) in
        {31}if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        {34}insert freshness(sci_A_2,an_1,packet_number);
        {29}let kek_context_1: nat = 10 in
        {32}let kek_1: key = kdf(szk_2,kek_context_1) in
        {33}let sak_1: key = key_dec(x,kek_1) in
        {35}insert association_keys(sci_A_2,an_1,sak_1)
) | (
    {37}phase 1;
    (
        {38}!
        {42}let an_2: nat = 1 in
        {40}let sci_A_3: bitstring = sci_A in
        {48}get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        {43}let packet_number_1: nat = 2 in
        {39}let m: bitstring = msg in
        {46}event message_send_Alice(m,packet_number_1);
        {44}let msg_2: bitstring = enc(m,sak_alice) in
        {45}let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        {47}out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        {49}!
        {52}in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        {50}let sci_A_4: bitstring = sci_A in
        {66}get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            {57}get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                {53}if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                {55}insert freshness(sci_A_4,an_3,packet_number_2);
                {54}let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                {56}event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            {58}let ick_context_2: nat = 20 in
            {51}let szk_4: key = szk in
            {60}let ick_2: key = kdf(szk_4,ick_context_2) in
            {61}if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            {64}insert freshness(sci_A_4,an_3,packet_number_2);
            {59}let kek_context_2: nat = 10 in
            {62}let kek_2: key = kdf(szk_4,kek_context_2) in
            {63}let sak_2: key = key_dec(x_1,kek_2) in
            {65}insert association_keys(sci_A_4,an_3,sak_2)
    )
)

-- Query not (event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 127 rules (54 with conclusion selected). Queue: 34 rules.
Starting query not (event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1))
goal reachable: attacker(m_1) && attacker(packet_number_3) && attacker_p1(m_1) -> event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1)

Derivation:
Abbreviations:
sak_3 = sak[!1 = @sid]

1. We assume as hypothesis that
attacker_p1(m_1).

2. The attacker has some term k.
attacker(k).

3. We assume as hypothesis that
attacker(packet_number_3).

4. The attacker has some term an_4.
attacker(an_4).

5. We assume as hypothesis that
attacker(m_1).

6. By 5, the attacker may know m_1.
By 2, the attacker may know k.
Using the function enc the attacker may obtain enc(m_1,k).
attacker(enc(m_1,k)).

7. By 6, the attacker may know enc(m_1,k).
By 4, the attacker may know an_4.
By 3, the attacker may know packet_number_3.
By 2, the attacker may know k.
Using the function hmac the attacker may obtain hmac(enc(m_1,k),an_4,packet_number_3,k).
attacker(hmac(enc(m_1,k),an_4,packet_number_3,k)).

8. The message (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))) may be sent to the attacker at output {18}.
attacker((sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20)))).

9. By 8, the attacker may know (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))).
Using the function 1-proj-5-tuple the attacker may obtain sci_A[].
attacker(sci_A[]).

10. By 9, the attacker may know sci_A[].
By 4, the attacker may know an_4.
By 3, the attacker may know packet_number_3.
By 6, the attacker may know enc(m_1,k).
By 7, the attacker may know hmac(enc(m_1,k),an_4,packet_number_3,k).
Using the function 5-tuple the attacker may obtain (sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k)).
attacker((sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k))).

11. Using the function 0 the attacker may obtain 0.
attacker(0).

12. By 11, the attacker may know 0.
Using the function + the attacker may obtain 1.
attacker(1).

13. By 12, the attacker may know 1.
Using the function + the attacker may obtain 2.
attacker(2).

14. By 13, the attacker may know 2.
Using the function + the attacker may obtain 3.
attacker(3).

15. By 14, the attacker may know 3.
Using the function + the attacker may obtain 4.
attacker(4).

16. By 15, the attacker may know 4.
Using the function + the attacker may obtain 5.
attacker(5).

17. By 16, the attacker may know 5.
Using the function + the attacker may obtain 6.
attacker(6).

18. By 17, the attacker may know 6.
Using the function + the attacker may obtain 7.
attacker(7).

19. By 18, the attacker may know 7.
Using the function + the attacker may obtain 8.
attacker(8).

20. By 19, the attacker may know 8.
Using the function + the attacker may obtain 9.
attacker(9).

21. By 20, the attacker may know 9.
Using the function + the attacker may obtain 10.
attacker(10).

22. By 21, the attacker may know 10.
Using the function + the attacker may obtain 11.
attacker(11).

23. By 22, the attacker may know 11.
Using the function + the attacker may obtain 12.
attacker(12).

24. By 23, the attacker may know 12.
Using the function + the attacker may obtain 13.
attacker(13).

25. By 24, the attacker may know 13.
Using the function + the attacker may obtain 14.
attacker(14).

26. By 25, the attacker may know 14.
Using the function + the attacker may obtain 15.
attacker(15).

27. By 26, the attacker may know 15.
Using the function + the attacker may obtain 16.
attacker(16).

28. By 27, the attacker may know 16.
Using the function + the attacker may obtain 17.
attacker(17).

29. By 28, the attacker may know 17.
Using the function + the attacker may obtain 18.
attacker(18).

30. By 29, the attacker may know 18.
Using the function + the attacker may obtain 19.
attacker(19).

31. By 30, the attacker may know 19.
Using the function + the attacker may obtain 20.
attacker(20).

32. The message szk[] may be sent to the attacker at output {2}.
attacker(szk[]).

33. By 32, the attacker may know szk[].
By 31, the attacker may know 20.
Using the function kdf the attacker may obtain kdf(szk[],20).
attacker(kdf(szk[],20)).

34. The attacker has some term packet_number_4.
attacker(packet_number_4).

35. By 32, the attacker may know szk[].
By 21, the attacker may know 10.
Using the function kdf the attacker may obtain kdf(szk[],10).
attacker(kdf(szk[],10)).

36. By 2, the attacker may know k.
By 35, the attacker may know kdf(szk[],10).
Using the function key_enc the attacker may obtain key_enc(k,kdf(szk[],10)).
attacker(key_enc(k,kdf(szk[],10))).

37. By 36, the attacker may know key_enc(k,kdf(szk[],10)).
By 4, the attacker may know an_4.
By 34, the attacker may know packet_number_4.
By 33, the attacker may know kdf(szk[],20).
Using the function hmac the attacker may obtain hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)).
attacker(hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))).

38. By 9, the attacker may know sci_A[].
By 4, the attacker may know an_4.
By 34, the attacker may know packet_number_4.
By 36, the attacker may know key_enc(k,kdf(szk[],10)).
By 37, the attacker may know hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)).
Using the function 5-tuple the attacker may obtain (sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))).
attacker((sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)))).

39. The message (sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))) that the attacker may have by 38 may be received at input {22}.
So the entry association_keys(sci_A[],an_4,k) may be inserted in a table at insert {35}.
table(association_keys(sci_A[],an_4,k)).

40. The message (sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k)) that the attacker may have by 10 may be received at input {22}.
The entry association_keys(sci_A[],an_4,k) that may be in a table by 39 may be read at get {36}.
So event message_received_Bob(m_1,packet_number_3) may be executed at {26}.
event(message_received_Bob(m_1,packet_number_3)).

41. By 40, event(message_received_Bob(m_1,packet_number_3)).
By 1, attacker_p1(m_1).
The goals are reached, combined in the following fact:
event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1).


Initial state

Additional knowledge of the attacker:
scA
a
a_1
a_2
hmac(enc(a_3,a),a_2,a_1,a)
enc(a_3,a)
a_3
a_4
--------------------------------------------------------------
New processes:
    new szk: key;
    out(scA, szk);
    new sci_A: bitstring;
    new msg: bitstring;
    insert freshness(sci_A,0,0);
    (
        !
        new sak: key;
        let kek_context: nat = 10 in
        let szk_1: key = szk in
        let kek: key = kdf(szk_1,kek_context) in
        let msg_1: bitstring = key_enc(sak,kek) in
        let ick_context: nat = 20 in
        let ick: key = kdf(szk_1,ick_context) in
        let an: nat = 1 in
        let icv: bitstring = hmac(msg_1,an,1,ick) in
        let fresh: nat = 1 in
        let sci_A_1: bitstring = sci_A in
        out(scA, (sci_A_1,an,fresh,msg_1,icv))
    ) | (
        !
        in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
        let sci_A_2: bitstring = sci_A in
        get association_keys(=sci,=an_1,ska_A: key) in
        (
            get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
                0
            else
                if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
                insert freshness(sci_A_2,an_1,packet_number);
                let received_msg: bitstring = dec(x,ska_A) in
                event message_received_Bob(received_msg,packet_number)
        )
        else
            let ick_context_1: nat = 20 in
            let szk_2: key = szk in
            let ick_1: key = kdf(szk_2,ick_context_1) in
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let kek_context_1: nat = 10 in
            let kek_1: key = kdf(szk_2,kek_context_1) in
            let sak_1: key = key_dec(x,kek_1) in
            insert association_keys(sci_A_2,an_1,sak_1)
    ) | (
        phase 1;
        (
            !
            let an_2: nat = 1 in
            let sci_A_3: bitstring = sci_A in
            get association_keys(=sci_A_3,=an_2,sak_alice: key) in
            let packet_number_1: nat = 2 in
            let m: bitstring = msg in
            event message_send_Alice(m,packet_number_1);
            let msg_2: bitstring = enc(m,sak_alice) in
            let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
            out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
        ) | (
            !
            in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
            let sci_A_4: bitstring = sci_A in
            get association_keys(=sci_1,=an_3,ska_A_1: key) in
            (
                get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                    0
                else
                    if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                    insert freshness(sci_A_4,an_3,packet_number_2);
                    let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                    event message_received_Bob(received_msg_1,packet_number_2)
            )
            else
                let ick_context_2: nat = 20 in
                let szk_4: key = szk in
                let ick_2: key = kdf(szk_4,ick_context_2) in
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let kek_context_2: nat = 10 in
                let kek_2: key = kdf(szk_4,kek_context_2) in
                let sak_2: key = key_dec(x_1,kek_2) in
                insert association_keys(sci_A_4,an_3,sak_2)
        )
    )

--------------------------------------------------------------
1st process: new szk: key creating szk_5

1st process: out(scA, ~M) with ~M = szk_5 done

Additional knowledge of the attacker:
hmac(key_enc(a,kdf(~M,10)),a_2,a_4,kdf(~M,20)) = hmac(key_enc(a,kdf(szk_5,10)),a_2,a_4,kdf(szk_5,20))
key_enc(a,kdf(~M,10)) = key_enc(a,kdf(szk_5,10))
kdf(~M,10) = kdf(szk_5,10)
kdf(~M,20) = kdf(szk_5,20)
~M = szk_5
--------------------------------------------------------------
1st process: new sci_A: bitstring creating sci_A_5

1st process: new msg: bitstring creating msg_3

1st process: insert freshness(sci_A_5,0,0) done

1st process: Reduction |

1st process: Reduction |

2nd process: Reduction ! 2 copy(ies)

3rd process: Beginning of process Bob

2nd process: Beginning of process Bob

1st process: Reduction ! 1 copy(ies)

1st process: Beginning of process Trant

1st process: new sak: key creating sak_4

1st process: let kek_context: nat = 10 succeeds

1st process: let szk_1: key = szk_5 succeeds

1st process: let kek: key = kdf(szk_5,10) succeeds

1st process: let msg_1: bitstring = key_enc(sak_4,kdf(szk_5,10)) succeeds

1st process: let ick_context: nat = 20 succeeds

1st process: let ick: key = kdf(szk_5,20) succeeds

1st process: let an: nat = 1 succeeds

1st process: let icv: bitstring = hmac(key_enc(sak_4,kdf(szk_5,10)),1,1,kdf(szk_5,20)) succeeds

1st process: let fresh: nat = 1 succeeds

1st process: let sci_A_1: bitstring = sci_A_5 succeeds

1st process: out(scA, (~M_1,1,1,~M_2,~M_3)) with ~M_1 = sci_A_5, ~M_2 = key_enc(sak_4,kdf(szk_5,10)), ~M_3 = hmac(key_enc(sak_4,kdf(szk_5,10)),1,1,kdf(szk_5,20)) done

Additional knowledge of the attacker:
~M_3 = hmac(key_enc(sak_4,kdf(szk_5,10)),1,1,kdf(szk_5,20))
~M_2 = key_enc(sak_4,kdf(szk_5,10))
~M_1 = sci_A_5
--------------------------------------------------------------
1st process: Reduction 0

New processes:
(
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let ick_context_1: nat = 20 in
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,ick_context_1) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_context_1: nat = 10 in
        let kek_1: key = kdf(szk_2,kek_context_1) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let ick_context_1: nat = 20 in
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,ick_context_1) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_context_1: nat = 10 in
        let kek_1: key = kdf(szk_2,kek_context_1) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    phase 1;
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let ick_context_2: nat = 20 in
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,ick_context_2) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_context_2: nat = 10 in
            let kek_2: key = kdf(szk_4,kek_context_2) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )
)

--------------------------------------------------------------
1st process: in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring)) done with message (~M_1,a_2,a_4,key_enc(a,kdf(~M,10)),hmac(key_enc(a,kdf(~M,10)),a_2,a_4,kdf(~M,20))) = (sci_A_5,a_2,a_4,key_enc(a,kdf(szk_5,10)),hmac(key_enc(a,kdf(szk_5,10)),a_2,a_4,kdf(szk_5,20)))

1st process: let sci_A_2: bitstring = sci_A_5 succeeds

1st process: get association_keys(=sci_A_5,=a_2,ska_A: key): else branch taken

1st process: let ick_context_1: nat = 20 succeeds

1st process: let szk_2: key = szk_5 succeeds

1st process: let ick_1: key = kdf(szk_5,20) succeeds

1st process: if ((sci_A_5 = sci_A_5) && (hmac(key_enc(a,kdf(szk_5,10)),a_2,a_4,kdf(szk_5,20)) = hmac(key_enc(a,kdf(szk_5,10)),a_2,a_4,kdf(szk_5,20)))) succeeds

1st process: insert freshness(sci_A_5,a_2,a_4) done

1st process: let kek_context_1: nat = 10 succeeds

1st process: let kek_1: key = kdf(szk_5,10) succeeds

1st process: let sak_1: key = key_dec(key_enc(a,kdf(szk_5,10)),kdf(szk_5,10)) succeeds

1st process: insert association_keys(sci_A_5,a_2,key_dec(key_enc(a,kdf(szk_5,10)),kdf(szk_5,10))) done

1st process: Reduction 0

New processes:
(
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let ick_context_1: nat = 20 in
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,ick_context_1) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_context_1: nat = 10 in
        let kek_1: key = kdf(szk_2,kek_context_1) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    phase 1;
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let ick_context_2: nat = 20 in
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,ick_context_2) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_context_2: nat = 10 in
            let kek_2: key = kdf(szk_4,kek_context_2) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )
)

--------------------------------------------------------------
1st process: in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring)) done with message (~M_1,a_2,a_1,enc(a_3,a),hmac(enc(a_3,a),a_2,a_1,a)) = (sci_A_5,a_2,a_1,enc(a_3,a),hmac(enc(a_3,a),a_2,a_1,a))

1st process: let sci_A_2: bitstring = sci_A_5 succeeds

1st process: get association_keys(=sci_A_5,=a_2,ska_A: key) done with entry association_keys(sci_A_5,a_2,a)

1st process: get freshness(=sci_A_5,=a_2,fv: nat) suchthat (fv ≥ a_1): else branch taken

1st process: if ((sci_A_5 = sci_A_5) && (hmac(enc(a_3,a),a_2,a_1,a) = hmac(enc(a_3,a),a_2,a_1,a))) succeeds

1st process: insert freshness(sci_A_5,a_2,a_1) done

1st process: let received_msg: bitstring = dec(enc(a_3,a),a) succeeds

1st process: event message_received_Bob(dec(enc(a_3,a),a),a_1) executed; it is a goal

New processes:
(
    0
) | (
    phase 1;
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let ick_context_2: nat = 20 in
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,ick_context_2) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_context_2: nat = 10 in
            let kek_2: key = kdf(szk_4,kek_context_2) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )
)

--------------------------------------------------------------
The event message_received_Bob(a_3,a_1) is executed at {26} in copy a_5.
The attacker has the message a_3 in phase 1.
A trace has been found, assuming the following hypothesis:
attacker_p1(a_3[])
goal reachable: attacker_p1(packet_number_3) && attacker_p1(m_1) -> event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1)

Derivation:
Abbreviations:
sak_3 = sak[!1 = @sid]

1. We assume as hypothesis that
attacker_p1(m_1).

2. The attacker has some term k in phase 1.
attacker_p1(k).

3. We assume as hypothesis that
attacker_p1(packet_number_3).

4. The attacker has some term an_4 in phase 1.
attacker_p1(an_4).

5. By 1, the attacker may know m_1 in phase 1.
By 2, the attacker may know k in phase 1.
Using the function enc the attacker may obtain enc(m_1,k) in phase 1.
attacker_p1(enc(m_1,k)).

6. By 5, the attacker may know enc(m_1,k) in phase 1.
By 4, the attacker may know an_4 in phase 1.
By 3, the attacker may know packet_number_3 in phase 1.
By 2, the attacker may know k in phase 1.
Using the function hmac the attacker may obtain hmac(enc(m_1,k),an_4,packet_number_3,k) in phase 1.
attacker_p1(hmac(enc(m_1,k),an_4,packet_number_3,k)).

7. The message (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))) may be sent to the attacker at output {18}.
attacker((sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20)))).

8. By 7, the attacker may know (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))).
Using the function 1-proj-5-tuple the attacker may obtain sci_A[].
attacker(sci_A[]).

9. By 8, the attacker may know sci_A[].
So the attacker may know sci_A[] in phase 1.
attacker_p1(sci_A[]).

10. By 9, the attacker may know sci_A[] in phase 1.
By 4, the attacker may know an_4 in phase 1.
By 3, the attacker may know packet_number_3 in phase 1.
By 5, the attacker may know enc(m_1,k) in phase 1.
By 6, the attacker may know hmac(enc(m_1,k),an_4,packet_number_3,k) in phase 1.
Using the function 5-tuple the attacker may obtain (sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k)) in phase 1.
attacker_p1((sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k))).

11. Using the function 0 the attacker may obtain 0 in phase 1.
attacker_p1(0).

12. By 11, the attacker may know 0 in phase 1.
Using the function + the attacker may obtain 1 in phase 1.
attacker_p1(1).

13. By 12, the attacker may know 1 in phase 1.
Using the function + the attacker may obtain 2 in phase 1.
attacker_p1(2).

14. By 13, the attacker may know 2 in phase 1.
Using the function + the attacker may obtain 3 in phase 1.
attacker_p1(3).

15. By 14, the attacker may know 3 in phase 1.
Using the function + the attacker may obtain 4 in phase 1.
attacker_p1(4).

16. By 15, the attacker may know 4 in phase 1.
Using the function + the attacker may obtain 5 in phase 1.
attacker_p1(5).

17. By 16, the attacker may know 5 in phase 1.
Using the function + the attacker may obtain 6 in phase 1.
attacker_p1(6).

18. By 17, the attacker may know 6 in phase 1.
Using the function + the attacker may obtain 7 in phase 1.
attacker_p1(7).

19. By 18, the attacker may know 7 in phase 1.
Using the function + the attacker may obtain 8 in phase 1.
attacker_p1(8).

20. By 19, the attacker may know 8 in phase 1.
Using the function + the attacker may obtain 9 in phase 1.
attacker_p1(9).

21. By 20, the attacker may know 9 in phase 1.
Using the function + the attacker may obtain 10 in phase 1.
attacker_p1(10).

22. By 21, the attacker may know 10 in phase 1.
Using the function + the attacker may obtain 11 in phase 1.
attacker_p1(11).

23. By 22, the attacker may know 11 in phase 1.
Using the function + the attacker may obtain 12 in phase 1.
attacker_p1(12).

24. By 23, the attacker may know 12 in phase 1.
Using the function + the attacker may obtain 13 in phase 1.
attacker_p1(13).

25. By 24, the attacker may know 13 in phase 1.
Using the function + the attacker may obtain 14 in phase 1.
attacker_p1(14).

26. By 25, the attacker may know 14 in phase 1.
Using the function + the attacker may obtain 15 in phase 1.
attacker_p1(15).

27. By 26, the attacker may know 15 in phase 1.
Using the function + the attacker may obtain 16 in phase 1.
attacker_p1(16).

28. By 27, the attacker may know 16 in phase 1.
Using the function + the attacker may obtain 17 in phase 1.
attacker_p1(17).

29. By 28, the attacker may know 17 in phase 1.
Using the function + the attacker may obtain 18 in phase 1.
attacker_p1(18).

30. By 29, the attacker may know 18 in phase 1.
Using the function + the attacker may obtain 19 in phase 1.
attacker_p1(19).

31. By 30, the attacker may know 19 in phase 1.
Using the function + the attacker may obtain 20 in phase 1.
attacker_p1(20).

32. The message szk[] may be sent to the attacker at output {2}.
attacker(szk[]).

33. By 32, the attacker may know szk[].
So the attacker may know szk[] in phase 1.
attacker_p1(szk[]).

34. By 33, the attacker may know szk[] in phase 1.
By 31, the attacker may know 20 in phase 1.
Using the function kdf the attacker may obtain kdf(szk[],20) in phase 1.
attacker_p1(kdf(szk[],20)).

35. The attacker has some term packet_number_4 in phase 1.
attacker_p1(packet_number_4).

36. By 33, the attacker may know szk[] in phase 1.
By 21, the attacker may know 10 in phase 1.
Using the function kdf the attacker may obtain kdf(szk[],10) in phase 1.
attacker_p1(kdf(szk[],10)).

37. By 2, the attacker may know k in phase 1.
By 36, the attacker may know kdf(szk[],10) in phase 1.
Using the function key_enc the attacker may obtain key_enc(k,kdf(szk[],10)) in phase 1.
attacker_p1(key_enc(k,kdf(szk[],10))).

38. By 37, the attacker may know key_enc(k,kdf(szk[],10)) in phase 1.
By 4, the attacker may know an_4 in phase 1.
By 35, the attacker may know packet_number_4 in phase 1.
By 34, the attacker may know kdf(szk[],20) in phase 1.
Using the function hmac the attacker may obtain hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)) in phase 1.
attacker_p1(hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))).

39. By 9, the attacker may know sci_A[] in phase 1.
By 4, the attacker may know an_4 in phase 1.
By 35, the attacker may know packet_number_4 in phase 1.
By 37, the attacker may know key_enc(k,kdf(szk[],10)) in phase 1.
By 38, the attacker may know hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)) in phase 1.
Using the function 5-tuple the attacker may obtain (sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))) in phase 1.
attacker_p1((sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)))).

40. The message (sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))) that the attacker may have in phase 1 by 39 may be received at input {52}.
So the entry association_keys(sci_A[],an_4,k) may be inserted in a table in phase 1 at insert {65}.
table_p1(association_keys(sci_A[],an_4,k)).

41. The message (sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k)) that the attacker may have in phase 1 by 10 may be received at input {52}.
The entry association_keys(sci_A[],an_4,k) that may be in a table in phase 1 by 40 may be read at get {66}.
So event message_received_Bob(m_1,packet_number_3) may be executed at {56}.
event(message_received_Bob(m_1,packet_number_3)).

42. By 41, event(message_received_Bob(m_1,packet_number_3)).
By 1, attacker_p1(m_1).
The goals are reached, combined in the following fact:
event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1).


Could not find a trace corresponding to this derivation.
RESULT not (event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1)) cannot be proved.
-- Query inj-event(message_received_Bob(m_1,packet_number_3)) ==> inj-event(message_send_Alice(m_1,packet_number_3)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 124 rules (54 with conclusion selected). Queue: 40 rules.
400 rules inserted. Base: 139 rules (79 with conclusion selected). Queue: 2 rules.
Starting query inj-event(message_received_Bob(m_1,packet_number_3)) ==> inj-event(message_send_Alice(m_1,packet_number_3))
goal reachable: attacker_p1(m_1) && attacker_p1(an_4) && attacker_p1(packet_number_3) && attacker_p1(k) -> inj-event(message_received_Bob(m_1,packet_number_3),@occ56_1)
Abbreviations:
@occ56_1 = @occ56[ska_A_1 = k,icv_2 = hmac(enc(m_1,k),an_4,packet_number_3,k),x_1 = enc(m_1,k),packet_number_2 = packet_number_3,an_3 = an_4,sci_1 = sci_A[],!1 = @sid]

Derivation:
Abbreviations:
@occ56_1 = @occ56[ska_A_1 = k,icv_2 = hmac(enc(m_1,k),an_4,packet_number_3,k),x_1 = enc(m_1,k),packet_number_2 = packet_number_3,an_3 = an_4,sci_1 = sci_A[],!1 = @sid]
sak_3 = sak[!1 = @sid_1]

1. We assume as hypothesis that
attacker_p1(k).

2. We assume as hypothesis that
attacker_p1(packet_number_3).

3. We assume as hypothesis that
attacker_p1(an_4).

4. We assume as hypothesis that
attacker_p1(m_1).

5. By 4, the attacker may know m_1 in phase 1.
By 1, the attacker may know k in phase 1.
Using the function enc the attacker may obtain enc(m_1,k) in phase 1.
attacker_p1(enc(m_1,k)).

6. By 5, the attacker may know enc(m_1,k) in phase 1.
By 3, the attacker may know an_4 in phase 1.
By 2, the attacker may know packet_number_3 in phase 1.
By 1, the attacker may know k in phase 1.
Using the function hmac the attacker may obtain hmac(enc(m_1,k),an_4,packet_number_3,k) in phase 1.
attacker_p1(hmac(enc(m_1,k),an_4,packet_number_3,k)).

7. The message (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))) may be sent to the attacker at output {18}.
attacker((sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20)))).

8. By 7, the attacker may know (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))).
Using the function 1-proj-5-tuple the attacker may obtain sci_A[].
attacker(sci_A[]).

9. By 8, the attacker may know sci_A[].
So the attacker may know sci_A[] in phase 1.
attacker_p1(sci_A[]).

10. By 9, the attacker may know sci_A[] in phase 1.
By 3, the attacker may know an_4 in phase 1.
By 2, the attacker may know packet_number_3 in phase 1.
By 5, the attacker may know enc(m_1,k) in phase 1.
By 6, the attacker may know hmac(enc(m_1,k),an_4,packet_number_3,k) in phase 1.
Using the function 5-tuple the attacker may obtain (sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k)) in phase 1.
attacker_p1((sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k))).

11. Using the function 0 the attacker may obtain 0 in phase 1.
attacker_p1(0).

12. By 11, the attacker may know 0 in phase 1.
Using the function + the attacker may obtain 1 in phase 1.
attacker_p1(1).

13. By 12, the attacker may know 1 in phase 1.
Using the function + the attacker may obtain 2 in phase 1.
attacker_p1(2).

14. By 13, the attacker may know 2 in phase 1.
Using the function + the attacker may obtain 3 in phase 1.
attacker_p1(3).

15. By 14, the attacker may know 3 in phase 1.
Using the function + the attacker may obtain 4 in phase 1.
attacker_p1(4).

16. By 15, the attacker may know 4 in phase 1.
Using the function + the attacker may obtain 5 in phase 1.
attacker_p1(5).

17. By 16, the attacker may know 5 in phase 1.
Using the function + the attacker may obtain 6 in phase 1.
attacker_p1(6).

18. By 17, the attacker may know 6 in phase 1.
Using the function + the attacker may obtain 7 in phase 1.
attacker_p1(7).

19. By 18, the attacker may know 7 in phase 1.
Using the function + the attacker may obtain 8 in phase 1.
attacker_p1(8).

20. By 19, the attacker may know 8 in phase 1.
Using the function + the attacker may obtain 9 in phase 1.
attacker_p1(9).

21. By 20, the attacker may know 9 in phase 1.
Using the function + the attacker may obtain 10 in phase 1.
attacker_p1(10).

22. By 21, the attacker may know 10 in phase 1.
Using the function + the attacker may obtain 11 in phase 1.
attacker_p1(11).

23. By 22, the attacker may know 11 in phase 1.
Using the function + the attacker may obtain 12 in phase 1.
attacker_p1(12).

24. By 23, the attacker may know 12 in phase 1.
Using the function + the attacker may obtain 13 in phase 1.
attacker_p1(13).

25. By 24, the attacker may know 13 in phase 1.
Using the function + the attacker may obtain 14 in phase 1.
attacker_p1(14).

26. By 25, the attacker may know 14 in phase 1.
Using the function + the attacker may obtain 15 in phase 1.
attacker_p1(15).

27. By 26, the attacker may know 15 in phase 1.
Using the function + the attacker may obtain 16 in phase 1.
attacker_p1(16).

28. By 27, the attacker may know 16 in phase 1.
Using the function + the attacker may obtain 17 in phase 1.
attacker_p1(17).

29. By 28, the attacker may know 17 in phase 1.
Using the function + the attacker may obtain 18 in phase 1.
attacker_p1(18).

30. By 29, the attacker may know 18 in phase 1.
Using the function + the attacker may obtain 19 in phase 1.
attacker_p1(19).

31. By 30, the attacker may know 19 in phase 1.
Using the function + the attacker may obtain 20 in phase 1.
attacker_p1(20).

32. The message szk[] may be sent to the attacker at output {2}.
attacker(szk[]).

33. By 32, the attacker may know szk[].
So the attacker may know szk[] in phase 1.
attacker_p1(szk[]).

34. By 33, the attacker may know szk[] in phase 1.
By 31, the attacker may know 20 in phase 1.
Using the function kdf the attacker may obtain kdf(szk[],20) in phase 1.
attacker_p1(kdf(szk[],20)).

35. The attacker has some term packet_number_4 in phase 1.
attacker_p1(packet_number_4).

36. By 33, the attacker may know szk[] in phase 1.
By 21, the attacker may know 10 in phase 1.
Using the function kdf the attacker may obtain kdf(szk[],10) in phase 1.
attacker_p1(kdf(szk[],10)).

37. By 1, the attacker may know k in phase 1.
By 36, the attacker may know kdf(szk[],10) in phase 1.
Using the function key_enc the attacker may obtain key_enc(k,kdf(szk[],10)) in phase 1.
attacker_p1(key_enc(k,kdf(szk[],10))).

38. By 37, the attacker may know key_enc(k,kdf(szk[],10)) in phase 1.
By 3, the attacker may know an_4 in phase 1.
By 35, the attacker may know packet_number_4 in phase 1.
By 34, the attacker may know kdf(szk[],20) in phase 1.
Using the function hmac the attacker may obtain hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)) in phase 1.
attacker_p1(hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))).

39. By 9, the attacker may know sci_A[] in phase 1.
By 3, the attacker may know an_4 in phase 1.
By 35, the attacker may know packet_number_4 in phase 1.
By 37, the attacker may know key_enc(k,kdf(szk[],10)) in phase 1.
By 38, the attacker may know hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)) in phase 1.
Using the function 5-tuple the attacker may obtain (sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))) in phase 1.
attacker_p1((sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)))).

40. The message (sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))) that the attacker may have in phase 1 by 39 may be received at input {52}.
So the entry association_keys(sci_A[],an_4,k) may be inserted in a table in phase 1 at insert {65}.
table_p1(association_keys(sci_A[],an_4,k)).

41. The message (sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k)) that the attacker may have in phase 1 by 10 may be received at input {52}.
The entry association_keys(sci_A[],an_4,k) that may be in a table in phase 1 by 40 may be read at get {66}.
So event message_received_Bob(m_1,packet_number_3) may be executed at {56} in session @sid.
inj-event(message_received_Bob(m_1,packet_number_3),@occ56_1).

42. By 41, inj-event(message_received_Bob(m_1,packet_number_3),@occ56_1).
The goal is reached, represented in the following fact:
inj-event(message_received_Bob(m_1,packet_number_3),@occ56_1).


Could not find a trace corresponding to this derivation.
goal reachable: attacker_p1(an_4) && attacker_p1(packet_number_3) && attacker(m_1) && attacker(an_4) && attacker(packet_number_3) && attacker(k) -> inj-event(message_received_Bob(m_1,packet_number_3),@occ56_1)
Abbreviations:
@occ56_1 = @occ56[ska_A_1 = k,icv_2 = hmac(enc(m_1,k),an_4,packet_number_3,k),x_1 = enc(m_1,k),packet_number_2 = packet_number_3,an_3 = an_4,sci_1 = sci_A[],!1 = @sid]

Derivation:
Abbreviations:
@occ56_1 = @occ56[ska_A_1 = k,icv_2 = hmac(enc(m_1,k),an_4,packet_number_3,k),x_1 = enc(m_1,k),packet_number_2 = packet_number_3,an_3 = an_4,sci_1 = sci_A[],!1 = @sid]
sak_3 = sak[!1 = @sid_1]

1. We assume as hypothesis that
attacker(k).

2. We assume as hypothesis that
attacker(packet_number_3).

3. We assume as hypothesis that
attacker(an_4).

4. We assume as hypothesis that
attacker(m_1).

5. By 4, the attacker may know m_1.
By 1, the attacker may know k.
Using the function enc the attacker may obtain enc(m_1,k).
attacker(enc(m_1,k)).

6. By 5, the attacker may know enc(m_1,k).
By 3, the attacker may know an_4.
By 2, the attacker may know packet_number_3.
By 1, the attacker may know k.
Using the function hmac the attacker may obtain hmac(enc(m_1,k),an_4,packet_number_3,k).
attacker(hmac(enc(m_1,k),an_4,packet_number_3,k)).

7. By 6, the attacker may know hmac(enc(m_1,k),an_4,packet_number_3,k).
So the attacker may know hmac(enc(m_1,k),an_4,packet_number_3,k) in phase 1.
attacker_p1(hmac(enc(m_1,k),an_4,packet_number_3,k)).

8. By 5, the attacker may know enc(m_1,k).
So the attacker may know enc(m_1,k) in phase 1.
attacker_p1(enc(m_1,k)).

9. We assume as hypothesis that
attacker_p1(packet_number_3).

10. We assume as hypothesis that
attacker_p1(an_4).

11. The message (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))) may be sent to the attacker at output {18}.
attacker((sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20)))).

12. By 11, the attacker may know (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))).
Using the function 1-proj-5-tuple the attacker may obtain sci_A[].
attacker(sci_A[]).

13. By 12, the attacker may know sci_A[].
So the attacker may know sci_A[] in phase 1.
attacker_p1(sci_A[]).

14. By 13, the attacker may know sci_A[] in phase 1.
By 10, the attacker may know an_4 in phase 1.
By 9, the attacker may know packet_number_3 in phase 1.
By 8, the attacker may know enc(m_1,k) in phase 1.
By 7, the attacker may know hmac(enc(m_1,k),an_4,packet_number_3,k) in phase 1.
Using the function 5-tuple the attacker may obtain (sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k)) in phase 1.
attacker_p1((sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k))).

15. Using the function 0 the attacker may obtain 0.
attacker(0).

16. By 15, the attacker may know 0.
Using the function + the attacker may obtain 1.
attacker(1).

17. By 16, the attacker may know 1.
Using the function + the attacker may obtain 2.
attacker(2).

18. By 17, the attacker may know 2.
Using the function + the attacker may obtain 3.
attacker(3).

19. By 18, the attacker may know 3.
Using the function + the attacker may obtain 4.
attacker(4).

20. By 19, the attacker may know 4.
Using the function + the attacker may obtain 5.
attacker(5).

21. By 20, the attacker may know 5.
Using the function + the attacker may obtain 6.
attacker(6).

22. By 21, the attacker may know 6.
Using the function + the attacker may obtain 7.
attacker(7).

23. By 22, the attacker may know 7.
Using the function + the attacker may obtain 8.
attacker(8).

24. By 23, the attacker may know 8.
Using the function + the attacker may obtain 9.
attacker(9).

25. By 24, the attacker may know 9.
Using the function + the attacker may obtain 10.
attacker(10).

26. By 25, the attacker may know 10.
Using the function + the attacker may obtain 11.
attacker(11).

27. By 26, the attacker may know 11.
Using the function + the attacker may obtain 12.
attacker(12).

28. By 27, the attacker may know 12.
Using the function + the attacker may obtain 13.
attacker(13).

29. By 28, the attacker may know 13.
Using the function + the attacker may obtain 14.
attacker(14).

30. By 29, the attacker may know 14.
Using the function + the attacker may obtain 15.
attacker(15).

31. By 30, the attacker may know 15.
Using the function + the attacker may obtain 16.
attacker(16).

32. By 31, the attacker may know 16.
Using the function + the attacker may obtain 17.
attacker(17).

33. By 32, the attacker may know 17.
Using the function + the attacker may obtain 18.
attacker(18).

34. By 33, the attacker may know 18.
Using the function + the attacker may obtain 19.
attacker(19).

35. By 34, the attacker may know 19.
Using the function + the attacker may obtain 20.
attacker(20).

36. The message szk[] may be sent to the attacker at output {2}.
attacker(szk[]).

37. By 36, the attacker may know szk[].
By 35, the attacker may know 20.
Using the function kdf the attacker may obtain kdf(szk[],20).
attacker(kdf(szk[],20)).

38. The attacker has some term packet_number_4.
attacker(packet_number_4).

39. By 36, the attacker may know szk[].
By 25, the attacker may know 10.
Using the function kdf the attacker may obtain kdf(szk[],10).
attacker(kdf(szk[],10)).

40. By 1, the attacker may know k.
By 39, the attacker may know kdf(szk[],10).
Using the function key_enc the attacker may obtain key_enc(k,kdf(szk[],10)).
attacker(key_enc(k,kdf(szk[],10))).

41. By 40, the attacker may know key_enc(k,kdf(szk[],10)).
By 3, the attacker may know an_4.
By 38, the attacker may know packet_number_4.
By 37, the attacker may know kdf(szk[],20).
Using the function hmac the attacker may obtain hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)).
attacker(hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))).

42. By 12, the attacker may know sci_A[].
By 3, the attacker may know an_4.
By 38, the attacker may know packet_number_4.
By 40, the attacker may know key_enc(k,kdf(szk[],10)).
By 41, the attacker may know hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)).
Using the function 5-tuple the attacker may obtain (sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))).
attacker((sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20)))).

43. The message (sci_A[],an_4,packet_number_4,key_enc(k,kdf(szk[],10)),hmac(key_enc(k,kdf(szk[],10)),an_4,packet_number_4,kdf(szk[],20))) that the attacker may have by 42 may be received at input {22}.
So the entry association_keys(sci_A[],an_4,k) may be inserted in a table at insert {35}.
table(association_keys(sci_A[],an_4,k)).

44. By 43, a table may contain the entry association_keys(sci_A[],an_4,k).
So a table may contain the entry association_keys(sci_A[],an_4,k) in phase 1.
table_p1(association_keys(sci_A[],an_4,k)).

45. The message (sci_A[],an_4,packet_number_3,enc(m_1,k),hmac(enc(m_1,k),an_4,packet_number_3,k)) that the attacker may have in phase 1 by 14 may be received at input {52}.
The entry association_keys(sci_A[],an_4,k) that may be in a table in phase 1 by 44 may be read at get {66}.
So event message_received_Bob(m_1,packet_number_3) may be executed at {56} in session @sid.
inj-event(message_received_Bob(m_1,packet_number_3),@occ56_1).

46. By 45, inj-event(message_received_Bob(m_1,packet_number_3),@occ56_1).
The goal is reached, represented in the following fact:
inj-event(message_received_Bob(m_1,packet_number_3),@occ56_1).


Initial state

Additional knowledge of the attacker:
scA
a
a_1
a_2
hmac(enc(a_3,a),a_2,a_1,a)
enc(a_3,a)
a_3
a_4
--------------------------------------------------------------
New processes:
    new szk: key;
    out(scA, szk);
    new sci_A: bitstring;
    new msg: bitstring;
    insert freshness(sci_A,0,0);
    (
        !
        new sak: key;
        let kek_context: nat = 10 in
        let szk_1: key = szk in
        let kek: key = kdf(szk_1,kek_context) in
        let msg_1: bitstring = key_enc(sak,kek) in
        let ick_context: nat = 20 in
        let ick: key = kdf(szk_1,ick_context) in
        let an: nat = 1 in
        let icv: bitstring = hmac(msg_1,an,1,ick) in
        let fresh: nat = 1 in
        let sci_A_1: bitstring = sci_A in
        out(scA, (sci_A_1,an,fresh,msg_1,icv))
    ) | (
        !
        in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
        let sci_A_2: bitstring = sci_A in
        get association_keys(=sci,=an_1,ska_A: key) in
        (
            get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
                0
            else
                if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
                insert freshness(sci_A_2,an_1,packet_number);
                let received_msg: bitstring = dec(x,ska_A) in
                event message_received_Bob(received_msg,packet_number)
        )
        else
            let ick_context_1: nat = 20 in
            let szk_2: key = szk in
            let ick_1: key = kdf(szk_2,ick_context_1) in
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let kek_context_1: nat = 10 in
            let kek_1: key = kdf(szk_2,kek_context_1) in
            let sak_1: key = key_dec(x,kek_1) in
            insert association_keys(sci_A_2,an_1,sak_1)
    ) | (
        phase 1;
        (
            !
            let an_2: nat = 1 in
            let sci_A_3: bitstring = sci_A in
            get association_keys(=sci_A_3,=an_2,sak_alice: key) in
            let packet_number_1: nat = 2 in
            let m: bitstring = msg in
            event message_send_Alice(m,packet_number_1);
            let msg_2: bitstring = enc(m,sak_alice) in
            let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
            out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
        ) | (
            !
            in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
            let sci_A_4: bitstring = sci_A in
            get association_keys(=sci_1,=an_3,ska_A_1: key) in
            (
                get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                    0
                else
                    if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                    insert freshness(sci_A_4,an_3,packet_number_2);
                    let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                    event message_received_Bob(received_msg_1,packet_number_2)
            )
            else
                let ick_context_2: nat = 20 in
                let szk_4: key = szk in
                let ick_2: key = kdf(szk_4,ick_context_2) in
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let kek_context_2: nat = 10 in
                let kek_2: key = kdf(szk_4,kek_context_2) in
                let sak_2: key = key_dec(x_1,kek_2) in
                insert association_keys(sci_A_4,an_3,sak_2)
        )
    )

--------------------------------------------------------------
1st process: new szk: key creating szk_5

1st process: out(scA, ~M) with ~M = szk_5 done

Additional knowledge of the attacker:
hmac(key_enc(a,kdf(~M,10)),a_2,a_4,kdf(~M,20)) = hmac(key_enc(a,kdf(szk_5,10)),a_2,a_4,kdf(szk_5,20))
key_enc(a,kdf(~M,10)) = key_enc(a,kdf(szk_5,10))
kdf(~M,10) = kdf(szk_5,10)
kdf(~M,20) = kdf(szk_5,20)
~M = szk_5
--------------------------------------------------------------
1st process: new sci_A: bitstring creating sci_A_5

1st process: new msg: bitstring creating msg_3

1st process: insert freshness(sci_A_5,0,0) done

1st process: Reduction |

1st process: Reduction |

2nd process: Reduction ! 1 copy(ies)

2nd process: Beginning of process Bob

1st process: Reduction ! 1 copy(ies)

1st process: Beginning of process Trant

1st process: new sak: key creating sak_4

1st process: let kek_context: nat = 10 succeeds

1st process: let szk_1: key = szk_5 succeeds

1st process: let kek: key = kdf(szk_5,10) succeeds

1st process: let msg_1: bitstring = key_enc(sak_4,kdf(szk_5,10)) succeeds

1st process: let ick_context: nat = 20 succeeds

1st process: let ick: key = kdf(szk_5,20) succeeds

1st process: let an: nat = 1 succeeds

1st process: let icv: bitstring = hmac(key_enc(sak_4,kdf(szk_5,10)),1,1,kdf(szk_5,20)) succeeds

1st process: let fresh: nat = 1 succeeds

1st process: let sci_A_1: bitstring = sci_A_5 succeeds

1st process: out(scA, (~M_1,1,1,~M_2,~M_3)) with ~M_1 = sci_A_5, ~M_2 = key_enc(sak_4,kdf(szk_5,10)), ~M_3 = hmac(key_enc(sak_4,kdf(szk_5,10)),1,1,kdf(szk_5,20)) done

Additional knowledge of the attacker:
~M_3 = hmac(key_enc(sak_4,kdf(szk_5,10)),1,1,kdf(szk_5,20))
~M_2 = key_enc(sak_4,kdf(szk_5,10))
~M_1 = sci_A_5
--------------------------------------------------------------
1st process: Reduction 0

New processes:
(
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let ick_context_1: nat = 20 in
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,ick_context_1) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_context_1: nat = 10 in
        let kek_1: key = kdf(szk_2,kek_context_1) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    phase 1;
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let ick_context_2: nat = 20 in
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,ick_context_2) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_context_2: nat = 10 in
            let kek_2: key = kdf(szk_4,kek_context_2) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )
)

--------------------------------------------------------------
1st process: in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring)) done with message (~M_1,a_2,a_4,key_enc(a,kdf(~M,10)),hmac(key_enc(a,kdf(~M,10)),a_2,a_4,kdf(~M,20))) = (sci_A_5,a_2,a_4,key_enc(a,kdf(szk_5,10)),hmac(key_enc(a,kdf(szk_5,10)),a_2,a_4,kdf(szk_5,20)))

1st process: let sci_A_2: bitstring = sci_A_5 succeeds

1st process: get association_keys(=sci_A_5,=a_2,ska_A: key): else branch taken

1st process: let ick_context_1: nat = 20 succeeds

1st process: let szk_2: key = szk_5 succeeds

1st process: let ick_1: key = kdf(szk_5,20) succeeds

1st process: if ((sci_A_5 = sci_A_5) && (hmac(key_enc(a,kdf(szk_5,10)),a_2,a_4,kdf(szk_5,20)) = hmac(key_enc(a,kdf(szk_5,10)),a_2,a_4,kdf(szk_5,20)))) succeeds

1st process: insert freshness(sci_A_5,a_2,a_4) done

1st process: let kek_context_1: nat = 10 succeeds

1st process: let kek_1: key = kdf(szk_5,10) succeeds

1st process: let sak_1: key = key_dec(key_enc(a,kdf(szk_5,10)),kdf(szk_5,10)) succeeds

1st process: insert association_keys(sci_A_5,a_2,key_dec(key_enc(a,kdf(szk_5,10)),kdf(szk_5,10))) done

1st process: Reduction 0

New processes:
    phase 1;
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let ick_context_2: nat = 20 in
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,ick_context_2) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_context_2: nat = 10 in
            let kek_2: key = kdf(szk_4,kek_context_2) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )

--------------------------------------------------------------
Switching to phase 1

Additional knowledge of the attacker:
a_1
a_2
--------------------------------------------------------------
New processes:
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let ick_context_2: nat = 20 in
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,ick_context_2) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_context_2: nat = 10 in
            let kek_2: key = kdf(szk_4,kek_context_2) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )

--------------------------------------------------------------
1st process: Reduction |

2nd process: Reduction ! 1 copy(ies)

2nd process: Beginning of process Bob

1st process: Reduction ! 0 copy(ies)

New processes:
    in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
    let sci_A_4: bitstring = sci_A_5 in
    get association_keys(=sci_1,=an_3,ska_A_1: key) in
    (
        get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
            0
        else
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let received_msg_1: bitstring = dec(x_1,ska_A_1) in
            event message_received_Bob(received_msg_1,packet_number_2)
    )
    else
        let ick_context_2: nat = 20 in
        let szk_4: key = szk_5 in
        let ick_2: key = kdf(szk_4,ick_context_2) in
        if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
        insert freshness(sci_A_4,an_3,packet_number_2);
        let kek_context_2: nat = 10 in
        let kek_2: key = kdf(szk_4,kek_context_2) in
        let sak_2: key = key_dec(x_1,kek_2) in
        insert association_keys(sci_A_4,an_3,sak_2)

--------------------------------------------------------------
1st process: in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring)) done with message (~M_1,a_2,a_1,enc(a_3,a),hmac(enc(a_3,a),a_2,a_1,a)) = (sci_A_5,a_2,a_1,enc(a_3,a),hmac(enc(a_3,a),a_2,a_1,a))

1st process: let sci_A_4: bitstring = sci_A_5 succeeds

1st process: get association_keys(=sci_A_5,=a_2,ska_A_1: key) done with entry association_keys(sci_A_5,a_2,a)

1st process: get freshness(=sci_A_5,=a_2,fv_1: nat) suchthat (fv_1 ≥ a_1): else branch taken

1st process: if ((sci_A_5 = sci_A_5) && (hmac(enc(a_3,a),a_2,a_1,a) = hmac(enc(a_3,a),a_2,a_1,a))) succeeds

1st process: insert freshness(sci_A_5,a_2,a_1) done

1st process: let received_msg_1: bitstring = dec(enc(a_3,a),a) succeeds

1st process: event message_received_Bob(dec(enc(a_3,a),a),a_1) executed; it is a goal

New processes:
    0

--------------------------------------------------------------
The event message_received_Bob(a_3,a_1) is executed at {56} in copy a_5.
A trace has been found.
RESULT inj-event(message_received_Bob(m_1,packet_number_3)) ==> inj-event(message_send_Alice(m_1,packet_number_3)) is false.
RESULT (even event(message_received_Bob(m_1,packet_number_3)) ==> event(message_send_Alice(m_1,packet_number_3)) is false.)

--------------------------------------------------------------
Verification summary:

Query not (event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1)) cannot be proved.

Query inj-event(message_received_Bob(m_1,packet_number_3)) ==> inj-event(message_send_Alice(m_1,packet_number_3)) is false.

--------------------------------------------------------------

