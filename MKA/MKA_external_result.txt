Linear part: No equation.
Convergent part:
dec(enc(m,k),k) = m
enc(dec(m,k),k) = m
key_dec(key_enc(k1,k2),k2) = k1
Completing equations...
Completed equations:
key_dec(key_enc(k1,k2),k2) = k1
enc(dec(m,k),k) = m
dec(enc(m,k),k) = m
Process 0 (that is, the initial process):
{1}new szk: key;
{2}new sci_A: bitstring;
{3}new msg: bitstring;
{4}let an: nat = 1 in
{5}insert freshness(sci_A,0,0);
(
    {6}!
    {7}let sci_A_1: bitstring = sci_A in
    {8}let fresh: nat = 1 in
    {9}let szk_1: key = szk in
    {10}let kek: key = kdf(szk_1,10) in
    {11}let ick: key = kdf(szk_1,20) in
    {12}new sak: key;
    {13}let msg_1: bitstring = key_enc(sak,kek) in
    {14}let icv: bitstring = hmac(msg_1,an,1,ick) in
    {15}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {16}!
    {17}let sci_A_2: bitstring = sci_A in
    {18}let szk_2: key = szk in
    {19}in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    {31}get association_keys(=sci,=an_1,ska_A: key) in
    (
        {24}get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            {20}if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            {21}let received_msg: bitstring = dec(x,ska_A) in
            {22}insert freshness(sci_A_2,an_1,packet_number);
            {23}event message_received_Bob(received_msg,packet_number)
    )
    else
        {25}let ick_1: key = kdf(szk_2,20) in
        {26}if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        {27}let kek_1: key = kdf(szk_2,10) in
        {28}let sak_1: key = key_dec(x,kek_1) in
        {29}insert freshness(sci_A_2,an_1,packet_number);
        {30}insert association_keys(sci_A_2,an_1,sak_1)
) | (
    {32}phase 1;
    (
        {33}!
        {34}let m: bitstring = msg in
        {35}let sci_A_3: bitstring = sci_A in
        {36}let szk_3: key = szk in
        {37}let an_2: nat = 1 in
        {43}get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        {38}let packet_number_1: nat = 2 in
        {39}let msg_2: bitstring = enc(m,sak_alice) in
        {40}let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        {41}event message_send_Alice(m,packet_number_1);
        {42}out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        {44}!
        {45}let sci_A_4: bitstring = sci_A in
        {46}let szk_4: key = szk in
        {47}in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        {59}get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            {52}get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                {48}if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                {49}let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                {50}insert freshness(sci_A_4,an_3,packet_number_2);
                {51}event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            {53}let ick_2: key = kdf(szk_4,20) in
            {54}if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            {55}let kek_2: key = kdf(szk_4,10) in
            {56}let sak_2: key = key_dec(x_1,kek_2) in
            {57}insert freshness(sci_A_4,an_3,packet_number_2);
            {58}insert association_keys(sci_A_4,an_3,sak_2)
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new szk: key;
{2}new sci_A: bitstring;
{3}new msg: bitstring;
{5}insert freshness(sci_A,0,0);
(
    {6}!
    {12}new sak: key;
    {9}let szk_1: key = szk in
    {10}let kek: key = kdf(szk_1,10) in
    {13}let msg_1: bitstring = key_enc(sak,kek) in
    {11}let ick: key = kdf(szk_1,20) in
    {4}let an: nat = 1 in
    {14}let icv: bitstring = hmac(msg_1,an,1,ick) in
    {8}let fresh: nat = 1 in
    {7}let sci_A_1: bitstring = sci_A in
    {15}out(scA, (sci_A_1,an,fresh,msg_1,icv))
) | (
    {16}!
    {19}in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    {17}let sci_A_2: bitstring = sci_A in
    {31}get association_keys(=sci,=an_1,ska_A: key) in
    (
        {24}get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            {20}if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            {22}insert freshness(sci_A_2,an_1,packet_number);
            {21}let received_msg: bitstring = dec(x,ska_A) in
            {23}event message_received_Bob(received_msg,packet_number)
    )
    else
        {18}let szk_2: key = szk in
        {25}let ick_1: key = kdf(szk_2,20) in
        {26}if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        {29}insert freshness(sci_A_2,an_1,packet_number);
        {27}let kek_1: key = kdf(szk_2,10) in
        {28}let sak_1: key = key_dec(x,kek_1) in
        {30}insert association_keys(sci_A_2,an_1,sak_1)
) | (
    {32}phase 1;
    (
        {33}!
        {37}let an_2: nat = 1 in
        {35}let sci_A_3: bitstring = sci_A in
        {43}get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        {38}let packet_number_1: nat = 2 in
        {34}let m: bitstring = msg in
        {41}event message_send_Alice(m,packet_number_1);
        {39}let msg_2: bitstring = enc(m,sak_alice) in
        {40}let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        {42}out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        {44}!
        {47}in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        {45}let sci_A_4: bitstring = sci_A in
        {59}get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            {52}get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                {48}if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                {50}insert freshness(sci_A_4,an_3,packet_number_2);
                {49}let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                {51}event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            {46}let szk_4: key = szk in
            {53}let ick_2: key = kdf(szk_4,20) in
            {54}if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            {57}insert freshness(sci_A_4,an_3,packet_number_2);
            {55}let kek_2: key = kdf(szk_4,10) in
            {56}let sak_2: key = key_dec(x_1,kek_2) in
            {58}insert association_keys(sci_A_4,an_3,sak_2)
    )
)

-- Query not (event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 156 rules (45 with conclusion selected). Queue: 28 rules.
Starting query not (event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1))
RESULT not (event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1)) is true.
-- Query inj-event(message_received_Bob(m_1,packet_number_3)) ==> inj-event(message_send_Alice(m_1,packet_number_3)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 154 rules (45 with conclusion selected). Queue: 31 rules.
Starting query inj-event(message_received_Bob(m_1,packet_number_3)) ==> inj-event(message_send_Alice(m_1,packet_number_3))
goal reachable: @sid ≠ @sid_1 && b-inj-event(message_send_Alice(msg[],2),@occ41_1) -> inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_1) && inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_2)
Abbreviations:
sak_3 = sak[!1 = @sid_2]
@occ51_1 = @occ51[ska_A_1 = key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)),icv_2 = hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),x_1 = enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),packet_number_2 = 2,an_3 = 1,sci_1 = sci_A[],!1 = @sid]
@occ51_2 = @occ51[ska_A_1 = key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)),icv_2 = hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),x_1 = enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),packet_number_2 = 2,an_3 = 1,sci_1 = sci_A[],!1 = @sid_1]
@occ41_1 = @occ41[sak_alice = key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)),!1 = @sid_3]

Derivation:
Abbreviations:
sak_3 = sak[!1 = @sid]
@occ51_1 = @occ51[ska_A_1 = key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)),icv_2 = hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),x_1 = enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),packet_number_2 = 2,an_3 = 1,sci_1 = sci_A[],!1 = @sid_1]
@occ51_2 = @occ51[ska_A_1 = key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)),icv_2 = hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),x_1 = enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),packet_number_2 = 2,an_3 = 1,sci_1 = sci_A[],!1 = @sid_2]
@occ41_1 = @occ41[sak_alice = key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)),!1 = @sid_3]
sak_4 = sak[!1 = @sid_4]

1. The message (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))) may be sent to the attacker at output {15}.
attacker((sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20)))).

2. By 1, the attacker may know (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))).
Using the function 5-proj-5-tuple the attacker may obtain hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20)).
attacker(hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))).

3. By 1, the attacker may know (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))).
Using the function 4-proj-5-tuple the attacker may obtain key_enc(sak_3,kdf(szk[],10)).
attacker(key_enc(sak_3,kdf(szk[],10))).

4. Using the function 0 the attacker may obtain 0.
attacker(0).

5. By 4, the attacker may know 0.
Using the function + the attacker may obtain 1.
attacker(1).

6. The message (sci_A[],1,1,key_enc(sak_4,kdf(szk[],10)),hmac(key_enc(sak_4,kdf(szk[],10)),1,1,kdf(szk[],20))) may be sent to the attacker at output {15}.
attacker((sci_A[],1,1,key_enc(sak_4,kdf(szk[],10)),hmac(key_enc(sak_4,kdf(szk[],10)),1,1,kdf(szk[],20)))).

7. By 6, the attacker may know (sci_A[],1,1,key_enc(sak_4,kdf(szk[],10)),hmac(key_enc(sak_4,kdf(szk[],10)),1,1,kdf(szk[],20))).
Using the function 1-proj-5-tuple the attacker may obtain sci_A[].
attacker(sci_A[]).

8. By 7, the attacker may know sci_A[].
By 5, the attacker may know 1.
By 5, the attacker may know 1.
By 3, the attacker may know key_enc(sak_3,kdf(szk[],10)).
By 2, the attacker may know hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20)).
Using the function 5-tuple the attacker may obtain (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))).
attacker((sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20)))).

9. The message (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))) that the attacker may have by 8 may be received at input {19}.
So the entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) may be inserted in a table at insert {30}.
table(association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))).

10. By 9, a table may contain the entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))).
So a table may contain the entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) in phase 1.
table_p1(association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))).

11. The entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) that may be in a table in phase 1 by 10 may be read at get {43}.
The event message_send_Alice(msg[],2) (with occurrence name @occ41_1) may be executed at {41}.
So the message (sci_A[],1,2,enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))) may be sent to the attacker in phase 1 at output {42}.
attacker_p1((sci_A[],1,2,enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))))).

12. By 11, the attacker may know (sci_A[],1,2,enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))) in phase 1.
Using the function 5-proj-5-tuple the attacker may obtain hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) in phase 1.
attacker_p1(hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))).

13. By 11, the attacker may know (sci_A[],1,2,enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))) in phase 1.
Using the function 4-proj-5-tuple the attacker may obtain enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) in phase 1.
attacker_p1(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))).

14. Using the function 0 the attacker may obtain 0 in phase 1.
attacker_p1(0).

15. By 14, the attacker may know 0 in phase 1.
Using the function + the attacker may obtain 1 in phase 1.
attacker_p1(1).

16. By 15, the attacker may know 1 in phase 1.
Using the function + the attacker may obtain 2 in phase 1.
attacker_p1(2).

17. By 7, the attacker may know sci_A[].
So the attacker may know sci_A[] in phase 1.
attacker_p1(sci_A[]).

18. By 17, the attacker may know sci_A[] in phase 1.
By 15, the attacker may know 1 in phase 1.
By 16, the attacker may know 2 in phase 1.
By 13, the attacker may know enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) in phase 1.
By 12, the attacker may know hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) in phase 1.
Using the function 5-tuple the attacker may obtain (sci_A[],1,2,enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))) in phase 1.
attacker_p1((sci_A[],1,2,enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))))).

19. The message (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))) that the attacker may have by 8 may be received at input {19}.
So the entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) may be inserted in a table at insert {30}.
table(association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))).

20. By 19, a table may contain the entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))).
So a table may contain the entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) in phase 1.
table_p1(association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))).

21. The message (sci_A[],1,2,enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))) that the attacker may have in phase 1 by 18 may be received at input {47}.
The entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) that may be in a table in phase 1 by 20 may be read at get {59}.
So event message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2) may be executed at {51} in session @sid_2.
inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_2).

22. By 21, inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_2).
The goal is reached, represented in the following fact:
inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_2).

23. The message (sci_A[],1,1,key_enc(sak_3,kdf(szk[],10)),hmac(key_enc(sak_3,kdf(szk[],10)),1,1,kdf(szk[],20))) that the attacker may have by 8 may be received at input {19}.
So the entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) may be inserted in a table at insert {30}.
table(association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))).

24. By 23, a table may contain the entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))).
So a table may contain the entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) in phase 1.
table_p1(association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))).

25. The message (sci_A[],1,2,enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),hmac(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),1,2,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10)))) that the attacker may have in phase 1 by 18 may be received at input {47}.
The entry association_keys(sci_A[],1,key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))) that may be in a table in phase 1 by 24 may be read at get {59}.
So event message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2) may be executed at {51} in session @sid_1.
inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_1).

26. By 25, inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_1).
The goal is reached, represented in the following fact:
inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_1).

27. By 26, inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_1).
By 22, inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_2).
We have @occ51_1 ≠ @occ51_2.
The goals for injectivity are reached, combined in the following fact:
inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_1) && inj-event(message_received_Bob(dec(enc(msg[],key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),key_dec(key_enc(sak_3,kdf(szk[],10)),kdf(szk[],10))),2),@occ51_2).


Initial state

Additional knowledge of the attacker:
scA
--------------------------------------------------------------
New processes:
    new szk: key;
    new sci_A: bitstring;
    new msg: bitstring;
    insert freshness(sci_A,0,0);
    (
        !
        new sak: key;
        let szk_1: key = szk in
        let kek: key = kdf(szk_1,10) in
        let msg_1: bitstring = key_enc(sak,kek) in
        let ick: key = kdf(szk_1,20) in
        let an: nat = 1 in
        let icv: bitstring = hmac(msg_1,an,1,ick) in
        let fresh: nat = 1 in
        let sci_A_1: bitstring = sci_A in
        out(scA, (sci_A_1,an,fresh,msg_1,icv))
    ) | (
        !
        in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
        let sci_A_2: bitstring = sci_A in
        get association_keys(=sci,=an_1,ska_A: key) in
        (
            get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
                0
            else
                if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
                insert freshness(sci_A_2,an_1,packet_number);
                let received_msg: bitstring = dec(x,ska_A) in
                event message_received_Bob(received_msg,packet_number)
        )
        else
            let szk_2: key = szk in
            let ick_1: key = kdf(szk_2,20) in
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let kek_1: key = kdf(szk_2,10) in
            let sak_1: key = key_dec(x,kek_1) in
            insert association_keys(sci_A_2,an_1,sak_1)
    ) | (
        phase 1;
        (
            !
            let an_2: nat = 1 in
            let sci_A_3: bitstring = sci_A in
            get association_keys(=sci_A_3,=an_2,sak_alice: key) in
            let packet_number_1: nat = 2 in
            let m: bitstring = msg in
            event message_send_Alice(m,packet_number_1);
            let msg_2: bitstring = enc(m,sak_alice) in
            let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
            out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
        ) | (
            !
            in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
            let sci_A_4: bitstring = sci_A in
            get association_keys(=sci_1,=an_3,ska_A_1: key) in
            (
                get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                    0
                else
                    if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                    insert freshness(sci_A_4,an_3,packet_number_2);
                    let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                    event message_received_Bob(received_msg_1,packet_number_2)
            )
            else
                let szk_4: key = szk in
                let ick_2: key = kdf(szk_4,20) in
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let kek_2: key = kdf(szk_4,10) in
                let sak_2: key = key_dec(x_1,kek_2) in
                insert association_keys(sci_A_4,an_3,sak_2)
        )
    )

--------------------------------------------------------------
1st process: new szk: key creating szk_5

1st process: new sci_A: bitstring creating sci_A_5

1st process: new msg: bitstring creating msg_3

1st process: insert freshness(sci_A_5,0,0) done

1st process: Reduction |

1st process: Reduction |

2nd process: Reduction ! 3 copy(ies)

4th process: Beginning of process Bob

3rd process: Beginning of process Bob

2nd process: Beginning of process Bob

1st process: Reduction ! 2 copy(ies)

2nd process: Beginning of process Trant

2nd process: new sak: key creating sak_5

2nd process: let szk_1: key = szk_5 succeeds

2nd process: let kek: key = kdf(szk_5,10) succeeds

2nd process: let msg_1: bitstring = key_enc(sak_5,kdf(szk_5,10)) succeeds

2nd process: let ick: key = kdf(szk_5,20) succeeds

2nd process: let an: nat = 1 succeeds

2nd process: let icv: bitstring = hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,kdf(szk_5,20)) succeeds

2nd process: let fresh: nat = 1 succeeds

2nd process: let sci_A_1: bitstring = sci_A_5 succeeds

2nd process: out(scA, (~M,1,1,~M_1,~M_2)) with ~M = sci_A_5, ~M_1 = key_enc(sak_5,kdf(szk_5,10)), ~M_2 = hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,kdf(szk_5,20)) done

Additional knowledge of the attacker:
~M_2 = hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,kdf(szk_5,20))
~M_1 = key_enc(sak_5,kdf(szk_5,10))
~M = sci_A_5
--------------------------------------------------------------
2nd process: Reduction 0

1st process: Beginning of process Trant

1st process: new sak: key creating sak_6

1st process: let szk_1: key = szk_5 succeeds

1st process: let kek: key = kdf(szk_5,10) succeeds

1st process: let msg_1: bitstring = key_enc(sak_6,kdf(szk_5,10)) succeeds

1st process: let ick: key = kdf(szk_5,20) succeeds

1st process: let an: nat = 1 succeeds

1st process: let icv: bitstring = hmac(key_enc(sak_6,kdf(szk_5,10)),1,1,kdf(szk_5,20)) succeeds

1st process: let fresh: nat = 1 succeeds

1st process: let sci_A_1: bitstring = sci_A_5 succeeds

1st process: out(scA, (~M_3,1,1,~M_4,~M_5)) with ~M_3 = sci_A_5, ~M_4 = key_enc(sak_6,kdf(szk_5,10)), ~M_5 = hmac(key_enc(sak_6,kdf(szk_5,10)),1,1,kdf(szk_5,20)) done

Additional knowledge of the attacker:
~M_5 = hmac(key_enc(sak_6,kdf(szk_5,10)),1,1,kdf(szk_5,20))
~M_4 = key_enc(sak_6,kdf(szk_5,10))
--------------------------------------------------------------
1st process: Reduction 0

New processes:
(
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,20) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_1: key = kdf(szk_2,10) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,20) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_1: key = kdf(szk_2,10) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,20) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_1: key = kdf(szk_2,10) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    phase 1;
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,20) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_2: key = kdf(szk_4,10) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )
)

--------------------------------------------------------------
1st process: in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring)) done with message (~M,1,1,~M_1,~M_2) = (sci_A_5,1,1,key_enc(sak_5,kdf(szk_5,10)),hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,kdf(szk_5,20)))

1st process: let sci_A_2: bitstring = sci_A_5 succeeds

1st process: get association_keys(=sci_A_5,=1,ska_A: key): else branch taken

1st process: let szk_2: key = szk_5 succeeds

1st process: let ick_1: key = kdf(szk_5,20) succeeds

1st process: if ((sci_A_5 = sci_A_5) && (hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,kdf(szk_5,20)) = hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,kdf(szk_5,20)))) succeeds

1st process: insert freshness(sci_A_5,1,1) done

1st process: let kek_1: key = kdf(szk_5,10) succeeds

1st process: let sak_1: key = key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10)) succeeds

1st process: insert association_keys(sci_A_5,1,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))) done

1st process: Reduction 0

New processes:
(
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,20) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_1: key = kdf(szk_2,10) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,20) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_1: key = kdf(szk_2,10) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    phase 1;
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,20) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_2: key = kdf(szk_4,10) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )
)

--------------------------------------------------------------
1st process: in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring)) done with message (~M,1,1,~M_1,~M_2) = (sci_A_5,1,1,key_enc(sak_5,kdf(szk_5,10)),hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,kdf(szk_5,20)))

1st process: let sci_A_2: bitstring = sci_A_5 succeeds

New processes:
(
    get association_keys(=sci_A_5,=1,ska_A: key) in
    (
        get freshness(=sci_A_5,=1,fv: nat) suchthat (fv ≥ 1) in
            0
        else
            if ((sci_A_5 = sci_A_5) && (hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,kdf(szk_5,20)) = hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,ska_A))) then
            insert freshness(sci_A_5,1,1);
            let received_msg: bitstring = dec(key_enc(sak_5,kdf(szk_5,10)),ska_A) in
            event message_received_Bob(received_msg,1)
    )
    else
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,20) in
        if ((sci_A_5 = sci_A_5) && (hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,kdf(szk_5,20)) = hmac(key_enc(sak_5,kdf(szk_5,10)),1,1,ick_1))) then
        insert freshness(sci_A_5,1,1);
        let kek_1: key = kdf(szk_2,10) in
        let sak_1: key = key_dec(key_enc(sak_5,kdf(szk_5,10)),kek_1) in
        insert association_keys(sci_A_5,1,sak_1)
) | (
    in(scA, (sci: bitstring,an_1: nat,packet_number: nat,x: bitstring,icv_1: bitstring));
    let sci_A_2: bitstring = sci_A_5 in
    get association_keys(=sci,=an_1,ska_A: key) in
    (
        get freshness(=sci,=an_1,fv: nat) suchthat (fv ≥ packet_number) in
            0
        else
            if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ska_A))) then
            insert freshness(sci_A_2,an_1,packet_number);
            let received_msg: bitstring = dec(x,ska_A) in
            event message_received_Bob(received_msg,packet_number)
    )
    else
        let szk_2: key = szk_5 in
        let ick_1: key = kdf(szk_2,20) in
        if ((sci = sci_A_2) && (icv_1 = hmac(x,an_1,packet_number,ick_1))) then
        insert freshness(sci_A_2,an_1,packet_number);
        let kek_1: key = kdf(szk_2,10) in
        let sak_1: key = key_dec(x,kek_1) in
        insert association_keys(sci_A_2,an_1,sak_1)
) | (
    phase 1;
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,20) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_2: key = kdf(szk_4,10) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )
)

--------------------------------------------------------------
Switching to phase 1

New processes:
    (
        !
        let an_2: nat = 1 in
        let sci_A_3: bitstring = sci_A_5 in
        get association_keys(=sci_A_3,=an_2,sak_alice: key) in
        let packet_number_1: nat = 2 in
        let m: bitstring = msg_3 in
        event message_send_Alice(m,packet_number_1);
        let msg_2: bitstring = enc(m,sak_alice) in
        let icv2: bitstring = hmac(msg_2,an_2,packet_number_1,sak_alice) in
        out(scA, (sci_A_3,an_2,packet_number_1,msg_2,icv2))
    ) | (
        !
        in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
        let sci_A_4: bitstring = sci_A_5 in
        get association_keys(=sci_1,=an_3,ska_A_1: key) in
        (
            get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
                0
            else
                if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
                insert freshness(sci_A_4,an_3,packet_number_2);
                let received_msg_1: bitstring = dec(x_1,ska_A_1) in
                event message_received_Bob(received_msg_1,packet_number_2)
        )
        else
            let szk_4: key = szk_5 in
            let ick_2: key = kdf(szk_4,20) in
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let kek_2: key = kdf(szk_4,10) in
            let sak_2: key = key_dec(x_1,kek_2) in
            insert association_keys(sci_A_4,an_3,sak_2)
    )

--------------------------------------------------------------
1st process: Reduction |

2nd process: Reduction ! 2 copy(ies)

3rd process: Beginning of process Bob

2nd process: Beginning of process Bob

1st process: Reduction ! 1 copy(ies)

1st process: Beginning of process Alice

1st process: let an_2: nat = 1 succeeds

1st process: let sci_A_3: bitstring = sci_A_5 succeeds

1st process: get association_keys(=sci_A_5,=1,sak_alice: key) done with entry association_keys(sci_A_5,1,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10)))

1st process: let packet_number_1: nat = 2 succeeds

1st process: let m: bitstring = msg_3 succeeds

1st process: event message_send_Alice(msg_3,2) executed

1st process: let msg_2: bitstring = enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))) succeeds

1st process: let icv2: bitstring = hmac(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),1,2,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))) succeeds

1st process: out(scA, (~M_6,1,2,~M_7,~M_8)) with ~M_6 = sci_A_5, ~M_7 = enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))), ~M_8 = hmac(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),1,2,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))) done

Additional knowledge of the attacker:
~M_8 = hmac(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),1,2,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10)))
~M_7 = enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10)))
--------------------------------------------------------------
1st process: Reduction 0

New processes:
(
    in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
    let sci_A_4: bitstring = sci_A_5 in
    get association_keys(=sci_1,=an_3,ska_A_1: key) in
    (
        get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
            0
        else
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let received_msg_1: bitstring = dec(x_1,ska_A_1) in
            event message_received_Bob(received_msg_1,packet_number_2)
    )
    else
        let szk_4: key = szk_5 in
        let ick_2: key = kdf(szk_4,20) in
        if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
        insert freshness(sci_A_4,an_3,packet_number_2);
        let kek_2: key = kdf(szk_4,10) in
        let sak_2: key = key_dec(x_1,kek_2) in
        insert association_keys(sci_A_4,an_3,sak_2)
) | (
    in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
    let sci_A_4: bitstring = sci_A_5 in
    get association_keys(=sci_1,=an_3,ska_A_1: key) in
    (
        get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
            0
        else
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let received_msg_1: bitstring = dec(x_1,ska_A_1) in
            event message_received_Bob(received_msg_1,packet_number_2)
    )
    else
        let szk_4: key = szk_5 in
        let ick_2: key = kdf(szk_4,20) in
        if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
        insert freshness(sci_A_4,an_3,packet_number_2);
        let kek_2: key = kdf(szk_4,10) in
        let sak_2: key = key_dec(x_1,kek_2) in
        insert association_keys(sci_A_4,an_3,sak_2)
)

--------------------------------------------------------------
1st process: in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring)) done with message (~M,1,2,~M_7,~M_8) = (sci_A_5,1,2,enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),hmac(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),1,2,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))))

1st process: let sci_A_4: bitstring = sci_A_5 succeeds

1st process: get association_keys(=sci_A_5,=1,ska_A_1: key) done with entry association_keys(sci_A_5,1,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10)))

1st process: get freshness(=sci_A_5,=1,fv_1: nat) suchthat (fv_1 ≥ 2): else branch taken

1st process: if ((sci_A_5 = sci_A_5) && (hmac(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),1,2,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))) = hmac(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),1,2,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))))) succeeds

New processes:
(
    insert freshness(sci_A_5,1,2);
    let received_msg_1: bitstring = dec(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))) in
    event message_received_Bob(received_msg_1,2)
) | (
    in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring));
    let sci_A_4: bitstring = sci_A_5 in
    get association_keys(=sci_1,=an_3,ska_A_1: key) in
    (
        get freshness(=sci_1,=an_3,fv_1: nat) suchthat (fv_1 ≥ packet_number_2) in
            0
        else
            if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ska_A_1))) then
            insert freshness(sci_A_4,an_3,packet_number_2);
            let received_msg_1: bitstring = dec(x_1,ska_A_1) in
            event message_received_Bob(received_msg_1,packet_number_2)
    )
    else
        let szk_4: key = szk_5 in
        let ick_2: key = kdf(szk_4,20) in
        if ((sci_1 = sci_A_4) && (icv_2 = hmac(x_1,an_3,packet_number_2,ick_2))) then
        insert freshness(sci_A_4,an_3,packet_number_2);
        let kek_2: key = kdf(szk_4,10) in
        let sak_2: key = key_dec(x_1,kek_2) in
        insert association_keys(sci_A_4,an_3,sak_2)
)

--------------------------------------------------------------
2nd process: in(scA, (sci_1: bitstring,an_3: nat,packet_number_2: nat,x_1: bitstring,icv_2: bitstring)) done with message (~M,1,2,~M_7,~M_8) = (sci_A_5,1,2,enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),hmac(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),1,2,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))))

2nd process: let sci_A_4: bitstring = sci_A_5 succeeds

2nd process: get association_keys(=sci_A_5,=1,ska_A_1: key) done with entry association_keys(sci_A_5,1,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10)))

2nd process: get freshness(=sci_A_5,=1,fv_1: nat) suchthat (fv_1 ≥ 2): else branch taken

2nd process: if ((sci_A_5 = sci_A_5) && (hmac(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),1,2,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))) = hmac(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),1,2,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))))) succeeds

2nd process: insert freshness(sci_A_5,1,2) done

2nd process: let received_msg_1: bitstring = dec(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))) succeeds

2nd process: event message_received_Bob(dec(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),2) executed; it is a goal

2nd process: Reduction 0

1st process: insert freshness(sci_A_5,1,2) done

1st process: let received_msg_1: bitstring = dec(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))) succeeds

1st process: event message_received_Bob(dec(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),2) executed; it is a goal

New processes:
    0

--------------------------------------------------------------
The event message_received_Bob(dec(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),2) is executed at {51} in copy a.
The event message_received_Bob(dec(enc(msg_3,key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),key_dec(key_enc(sak_5,kdf(szk_5,10)),kdf(szk_5,10))),2) is executed at {51} in copy a_1.
A trace has been found.
RESULT inj-event(message_received_Bob(m_1,packet_number_3)) ==> inj-event(message_send_Alice(m_1,packet_number_3)) is false.
RESULT (but event(message_received_Bob(m_1,packet_number_3)) ==> event(message_send_Alice(m_1,packet_number_3)) is true.)

--------------------------------------------------------------
Verification summary:

Query not (event(message_received_Bob(m_1,packet_number_3)) && attacker_p1(m_1)) is true.

Query inj-event(message_received_Bob(m_1,packet_number_3)) ==> inj-event(message_send_Alice(m_1,packet_number_3)) is false.

--------------------------------------------------------------

