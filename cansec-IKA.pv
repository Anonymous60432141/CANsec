set traceDisplay = long.

(* Define key type and channel *)
type key.
free scA: channel.

(* Encryption, Decryption, and HMAC functions *)
fun enc(bitstring, key): bitstring.
fun dec(bitstring, key): bitstring.
fun hmac(bitstring, nat, nat, key): bitstring.
fun kdf(key, nat):key.

(* Equations for symmetric encryption and decryption *)
equation forall m: bitstring, k: key; dec(enc(m, k), k) = m.
equation forall m: bitstring, k: key; enc(dec(m, k), k) = m.

(* Table to store freshness values to prevent replay attacks *)
table freshness(bitstring, nat).
table key_counter(bitstring, nat, key).

(* Events to track message sending, receiving, and replay detection *)
event message_received_Bob(bitstring, nat).
event message_send_Alice(bitstring, nat).
event replay_attack(bitstring, nat).
event replay_msg(bitstring, nat).

(* Alice sends a message to Peer B *)
let Alice(m: bitstring, sci_A: bitstring, szk: key, packet_number: nat, kc:nat) =
    let sak_alice = kdf(szk, kc+1) in
    let msg = enc(m, sak_alice) in
    let icv = hmac(msg, kc+1, packet_number, sak_alice) in
    event message_send_Alice(m, packet_number);
    out(scA, (sci_A, kc+1, packet_number, msg, icv)).

(* Bob receives and verifies the message from Peer A *)
let Bob(sci_A: bitstring, szk: key) =
    in(scA, (sci: bitstring, kc:nat, packet_number: nat, x: bitstring, icv: bitstring));
    get freshness(sci, fv) suchthat fv >= packet_number in 0 else
        get key_counter(sci, k, old_key) suchthat k >= kc in
            if sci = sci_A && icv = hmac(x, kc, packet_number, old_key) then
                let received_msg = dec(x, old_key) in
                insert freshness(sci_A, packet_number);
                event message_received_Bob(received_msg, packet_number)
            else
                event replay_attack(sci, packet_number)
        else
            let key = kdf(szk, kc) in
            if sci = sci_A && icv = hmac(x, kc, packet_number, key) then
                let received_msg = dec(x, key) in
                insert freshness(sci_A, packet_number);
                insert key_counter(sci_A, kc, key);
                event message_received_Bob(received_msg, packet_number)
            else
                event replay_attack(sci, packet_number).

(* Charlie attempts a replay attack *)
let Charlie() =
    in(scA, (sci: bitstring, packet_number: nat, x: bitstring, icv: bitstring));
    event replay_msg(sci, packet_number);  
    out(scA, (sci, packet_number+10, x, icv)).

(* Confidentiality Query: Ensure the attacker cannot learn the message *)
query m: bitstring, packet_number: nat;
    event(message_received_Bob(m, packet_number)) && attacker(m) ==> false.

(* Authentication Query: Ensure every message received was actually sent *)
query m: bitstring, packet_number: nat;
    event(message_received_Bob(m, packet_number)) ==> event(message_send_Alice(m, packet_number)).

(* Replay Attack Query: Ensure no message is accepted after a replay attack *)
query sci: bitstring, packet_number: nat;
    event(replay_attack(sci, packet_number)) ==> event(replay_msg(sci, packet_number)).

(* Main Process *)
process
    new szk: key;
    new sci_A: bitstring;
    new msg: bitstring;
    insert freshness(sci_A, 1); 
    insert key_counter(sci_A, 0, szk);
    (!Alice(msg, sci_A, szk, 2, 1) | !Bob(sci_A, szk) | !Charlie())
    

    
